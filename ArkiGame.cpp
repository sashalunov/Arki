#include "stdafx.h"
#include "imgui.h"
#include "imgui_impl_win32.h"
#include "imgui_impl_dx9.h"
#include "EmbeddedAssets.h" // The file generated by Python
#include "Sounds.h"
#include "CXAudio.h"
#include "CArkiBomb.h"
#include "CHUD.h"
#include "ArkiGame.h"

// Create a tween from 0 to 100 over 100 steps (or milliseconds)
auto tween = tweeny::from(0.0f)
.to(D3DX_PI).during(1000).via(easing::elasticInOutEasing())
.to(0).during(1000).via(easing::elasticInOutEasing());

static double tweenElapsedTime = 0;

// ------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------
ArkiGame::ArkiGame()
{
    m_pSkybox = NULL;
	m_pCam0 = NULL;
    m_pCamEditor = NULL;
    m_pBodyMesh = NULL;
    m_pSkullMesh = NULL;
    m_pTeapotMesh = NULL;
    eb = NULL;
    emmiter1 = NULL;
    es = NULL;
    m_val = 0.0f;
	m_player = NULL;
    m_isPaused = FALSE;
	m_showGrid = TRUE;

    m_mainMenu = new CMainMenu();
    m_gameState = STATE_MENU; // Start in menu

	m_grid = new CGrid();

	m_inputLeft = false;
	m_inputRight = false;
	m_isEditorMode = false;

    g_selected = NULL;
    g_gizmo = NULL;

    m_bulletManager = NULL;
	m_spawner = NULL;

    mouseDeltaX = 0;
	mouseDeltaY = 0;
    m_pq3bsp = NULL;
	m_phl1bsp = NULL;
	m_bspLevel = NULL;
	m_fpsPlayer = NULL;
	m_pTextureMgr = NULL;
	m_wadViewer = NULL;
	m_viewerOpen = FALSE;
}

// ------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------
bool ArkiGame::Init()
{
    // logger initialization
    if (!Log->Initialize())
        return FALSE;

    // d3d stuff
    if (!d3d9->Initialize())
        return FALSE;

	if (!xau->Initialize())
        return FALSE;

    RAWINPUTDEVICE Rid[1];
    Rid[0].usUsagePage = HID_USAGE_PAGE_GENERIC;
    Rid[0].usUsage = HID_USAGE_GENERIC_MOUSE;
    Rid[0].dwFlags = RIDEV_INPUTSINK;
    Rid[0].hwndTarget = d3d9->GetHWND();
    RegisterRawInputDevices(Rid, 1, sizeof(Rid[0]));

    InitGUI();
    InitPhysics();

	m_pTextureMgr = new TextureManager(d3d9->GetDevice());

    m_pCam0 = new CQuatCamera();
    m_pCam0->MoveLocal(-50, 0, 0);

    m_pCamEditor = new COrbitCamera();

    m_pSkybox = new CSkybox(d3d9->GetDevice(), L".\\null.dds");

    m_font = new CSpriteFont();
    m_font->InitFromMemory(d3d9->GetDevice(),
        FONT_DATA, FONT_DATA_SIZE,
        FONT_TEXTURE, FONT_TEXTURE_SIZE);

    m_pBodyMesh = new CXMesh(d3d9->GetDevice(), L".\\data\\body.x");
    m_pSkullMesh = new CXMesh(d3d9->GetDevice(), L".\\data\\skullocc.x");
    m_pTeapotMesh = new CXMesh(d3d9->GetDevice(), L".\\data\\teapot.x");

    //D3DXCreateSphere(d3d9->GetDevice(), 0.5f, 24, 32, &pSphereMesh, NULL);
    //D3DXCreateBox(d3d9->GetDevice(), 50, 2, 50, &pBoxMesh, NULL);
    CArkiBlock::InitSharedMesh(d3d9->GetDevice());
	CRigidBody::InitSharedMesh(d3d9->GetDevice());
    m_currentLevel = new CArkiLevel(g_dynamicsWorld);
    //m_currentLevel->GenerateRandomLevel(20, 18, false);
    m_currentLevel->GenerateMathLevel(21, 21);
	p = m_currentLevel->m_currentParams;
    m_player = new CArkiPlayer(g_dynamicsWorld, d3d9->GetDevice(), D3DXVECTOR3(0, -16, 0));
    g_HUD = new CHUD();
    g_HUD->Init(d3d9->GetDevice(), m_font, 1280, 720);

    DWORD dwShaderFlags = D3DXFX_NOT_CLONEABLE;
    #if defined( DEBUG ) || defined( _DEBUG )
        // Set the D3DXSHADER_DEBUG flag to embed debug information in the shaders.
        // Setting this flag improves the shader debugging experience, but still allows 
        // the shaders to be optimized and to run exactly the way they will run in 
        // the release configuration of this program.
        dwShaderFlags |= D3DXSHADER_DEBUG;
    #endif
    #ifdef DEBUG_VS
        dwShaderFlags |= D3DXSHADER_FORCE_VS_SOFTWARE_NOOPT;
    #endif
    #ifdef DEBUG_PS
        dwShaderFlags |= D3DXSHADER_FORCE_PS_SOFTWARE_NOOPT;
    #endif

	m_grid->Create(d3d9->GetDevice(), 100.0f, 1.0f);
    g_gizmo = new CGizmo(d3d9->GetDevice());

	m_sbatch = new CSpriteBatch();
	m_sbatch->Init(d3d9->GetDevice());

    CreateRadialGradientTexture(
        d3d9->GetDevice(),
        256,
        256,
        D3DCOLOR_ARGB(255,255, 255, 255), // Inner color (white)
        D3DCOLOR_ARGB(0,0, 0, 0),       // Outer color (black)
		&m_radialTex);


	emmiter1 = new ParticleEmitter(D3DXVECTOR3(0.0f, 50.0f, 0.0f), 150.0f);
	eb = new BoidEmitter(2048);
	es = new SphereEmitter(btVector3(0.0f, 15.0f, 0.0f), 5.0f, 330.0f);
	es->SetSurfaceOnly(true);

    // Create 3 segments (A, B, C)
    float segmentHeight = 25.0f;
    float currentVirtualY = 0.0f; // Global counter for noise

    for (int i = 0; i < 3; i++)
    {
        float startY = -100.0f + (i * segmentHeight); 

        // Left Wall
        CArkiCliffTreadmill* l = new CArkiCliffTreadmill(g_dynamicsWorld, d3d9->GetDevice(), segmentHeight, startY, -25.0f, false, currentVirtualY);
        m_leftWalls.push_back(l);

        // Right Wall
        CArkiCliffTreadmill* r = new CArkiCliffTreadmill(g_dynamicsWorld, d3d9->GetDevice(), segmentHeight, startY, 25.0f, true, currentVirtualY + 500.0f);
        m_rightWalls.push_back(r);
    }

    InitBagSystem();

    xau->LoadSoundFromMemory("shoot1", GeneratePlasmaShot());
    xau->LoadSoundFromMemory("explo1", GenerateExplosion());
    xau->LoadSoundFromMemory("knock", GenerateMutedKnock());
    xau->LoadSoundFromMemory("powerup", GeneratePowerupSound());
    xau->LoadSoundFromMemory("jump", GenerateJumpSound());
    xau->LoadSoundFromMemory("ding", GenerateMetallicDing());


    m_bulletManager = new CBulletManager(g_dynamicsWorld);
	m_spawner = new CEnemySpawner(g_dynamicsWorld, m_bulletManager, m_pTeapotMesh);

	m_bspLevel = new CBSPlevel();
    m_pq3bsp = new CQ3BSP();
	m_phl1bsp = new CHL1BSP();
	m_phl1bsp->SetTextureManager(m_pTextureMgr);

   /* if (!m_bspLevel->LoadOBJ(g_dynamicsWorld, ".\\room1a.obj"))
    {
        _log(L"Failed to load room1 obj!\n");
        return false;
	}*/
	m_fpsPlayer = new CFPSPlayer();
	m_fpsPlayer->Init(g_dynamicsWorld, m_pCam0, btVector3(5, 1, 20));
	m_wadViewer = new CWADViewer(m_pTextureMgr);
    SetRenderStateDefaults();

    _log(L"Initializing Done\n");


    return true;
}

void ArkiGame::SetRenderStateDefaults()
{
    // Light 0: Directional light from above
    InitLight(m_LightDefault, D3DLIGHT_DIRECTIONAL, 0.0f, -0.6f, -0.3f, 1.0f, 1.0f, 1.0f);
    d3d9->GetDevice()->SetLight(0, &m_LightDefault);
    d3d9->GetDevice()->LightEnable(0, TRUE);

    d3d9->GetDevice()->SetRenderState(D3DRS_COLORVERTEX, FALSE);
    d3d9->GetDevice()->SetRenderState(D3DRS_EMISSIVEMATERIALSOURCE, D3DMCS_MATERIAL);
    d3d9->GetDevice()->SetRenderState(D3DRS_AMBIENTMATERIALSOURCE, D3DMCS_MATERIAL);
    d3d9->GetDevice()->SetRenderState(D3DRS_DIFFUSEMATERIALSOURCE, D3DMCS_MATERIAL);
    d3d9->GetDevice()->SetRenderState(D3DRS_SPECULARMATERIALSOURCE, D3DMCS_MATERIAL);
    d3d9->GetDevice()->SetRenderState(D3DRS_ZENABLE, TRUE);
    d3d9->GetDevice()->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
    d3d9->GetDevice()->SetRenderState(D3DRS_FILLMODE, D3DFILL_SOLID);
    d3d9->GetDevice()->SetRenderState(D3DRS_AMBIENT, D3DCOLOR_XRGB(32, 32, 64));
    d3d9->GetDevice()->SetRenderState(D3DRS_LIGHTING, TRUE);
    d3d9->GetDevice()->SetRenderState(D3DRS_SPECULARENABLE, TRUE);
    d3d9->GetDevice()->SetRenderState(D3DRS_NORMALIZENORMALS, TRUE);
}
// ------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------
void ArkiGame::Run()
{
    fFrameTime = (double)m_Timer.GetElapsedTime();
    fDeltaTime = (double)fFrameTime / 1000.0f;

	Update(fDeltaTime);
	Render(fDeltaTime);

    // Reset accumulators
    mouseDeltaX = 0;
    mouseDeltaY = 0;
	scrollAmount = 0.0f;
}

// ------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------
void ArkiGame::Update(double dt)
{
    if (m_isPaused) return;
    
    switch (m_gameState)
    {
    case STATE_MENU:
        break;
    case STATE_PLAYING_ARKI:
        ProcessArkiInput(dt);
        break;
    case STATE_PLAYING_FPS:
        ProcessFPSInput(dt);
        break;
    case STATE_PAUSED:
        break;
    case STATE_EDITOR:
        ProcessEditorInput(dt);
        break;
    case STATE_SETTINGS:
        break;
    case STATE_LEVEL_COMPLETE:
        break;
    default:
        break;
    }

    // Clamp huge spikes (e.g. if you dragged the window or hit a breakpoint)
    if (fDeltaTime > MAX_FRAME_TIME) 
        fDeltaTime = MAX_FRAME_TIME;
    // Add to accumulator
    g_accumulator += fDeltaTime;
    // Consume accumulator in fixed chunks
    // While we have enough accumulated time to run a physics step...
    while (g_accumulator >= FIXED_DT)
    {
        FixedUpdate(FIXED_DT);
        g_accumulator -= FIXED_DT;
    }
}

void ArkiGame::UpdateWalls(double dt)
{
    float scrollSpeed = 3.0f;
    float killY = -50.0f; // Point where wall is fully off-screen

    // ---------------------------------------------------------
    // STEP 1: MOVE EVERYTHING FIRST
    // ---------------------------------------------------------
    for (int i = 0; i < m_leftWalls.size(); i++) {
        m_leftWalls[i]->Scroll(dt, scrollSpeed);
    }
    for (int i = 0; i < m_rightWalls.size(); i++) {
        m_rightWalls[i]->Scroll(dt, scrollSpeed);
    }
    // ---------------------------------------------------------
    // STEP 2: CHECK RECYCLING (Now positions are synchronized)
    // ---------------------------------------------------------
    // Check Left Walls
    for (int i = 0; i < m_leftWalls.size(); i++)
    {
        CArkiCliffTreadmill* wall = m_leftWalls[i];

        if (wall->m_currentY < killY)
        {
            int topIndex = (i == 0) ? (int)m_leftWalls.size() - 1 : i - 1;
            CArkiCliffTreadmill* topWall = m_leftWalls[topIndex];

            // topWall has already moved this frame, so this calculation is safe
            float newY = topWall->m_currentY + topWall->m_height;
            wall->Regenerate(newY, topWall->m_topVirtualY);
        }
    }
    // Check Right Walls
    for (int i = 0; i < m_rightWalls.size(); i++)
    {
        CArkiCliffTreadmill* wall = m_rightWalls[i];

        if (wall->m_currentY < killY)
        {
            int topIndex = (i == 0) ? (int)m_rightWalls.size() - 1 : i - 1;
            CArkiCliffTreadmill* topWall = m_rightWalls[topIndex];

            float newY = topWall->m_currentY + topWall->m_height;
            wall->Regenerate(newY, topWall->m_topVirtualY);
        }
    }
}

// ------------------------------------------------------------------------------------
// This function runs exactly at 60Hz (or whatever FIXED_DT is)
// ------------------------------------------------------------------------------------
void ArkiGame::FixedUpdate(double fixedDeltaTime)
{
    UpdateWalls(fixedDeltaTime);
    if (g_dynamicsWorld) g_dynamicsWorld->stepSimulation((btScalar)fixedDeltaTime, 1, (btScalar)fixedDeltaTime);
    // 1. UPDATE LOOP
    for (int i = 0; i < (int)m_sceneObjects.size(); i++)
    {
        // This calls the Fuse Timer logic if it's a bomb
        m_sceneObjects[i]->Update(fixedDeltaTime);
    }
    // 2. CLEANUP LOOP (Remove exploded bombs)
    // We iterate backwards so we can delete without breaking the vector indices
    for (int i = (int)m_sceneObjects.size() - 1; i >= 0; i--)
    {
        CRigidBody* obj = m_sceneObjects[i];

        if (obj->IsDead())
        {
            // 1. Remove from Scene Vector
            m_sceneObjects.erase(m_sceneObjects.begin() + i);
            delete obj;
        }
    }

    // Update Logic / Particles
    if (emmiter1) emmiter1->Update((float)fixedDeltaTime);
    if (eb) eb->Update((float)fixedDeltaTime);
    if (es) es->Update((float)fixedDeltaTime);
	if (m_bulletManager)m_bulletManager->Update(fixedDeltaTime);
	if (m_player) m_player->Update((float)fixedDeltaTime, m_inputLeft, m_inputRight);
	if (m_currentLevel) m_currentLevel->Update();
    // Update Enemies
    for (auto e : m_enemies) {
        e->Update(fixedDeltaTime);
    }

    CheckCollisions(g_dynamicsWorld);

    // 4. Cleanup (Actually delete the bullets now that physics is done using them)
    if (m_player) m_player->CleanupBullets(); 
    if (m_currentLevel) m_currentLevel->CleanupBlocks();
    if (m_spawner)m_spawner->Update(fixedDeltaTime, m_player->GetPosition());

    CArkiPowerup* ap = NULL;
    // Update Powerups (Check bounds)
    for (int i = 0; i < m_powerups.size(); i++)
    {
        ap = m_powerups[i];
        float y = (FLOAT)ap->m_pBody->getWorldTransform().getOrigin().getY();

        // If it falls off the bottom of the screen (-15.0f depending on your cam)
        if (y < -25.0f || ap->m_markForDelete)
        {
            g_dynamicsWorld->removeRigidBody(ap->m_pBody);
            delete ap;
            m_powerups.erase(m_powerups.begin() + i);
            i--;
        }
    }

    for (int i = 0; i < m_ftext.size(); i++)
    {
        FloatingText3D* b = m_ftext[i];
        if (!b->isActive)
        {
            delete b;
            m_ftext.erase(m_ftext.begin() + i);
            i--;
        }
    }

	m_pCam0->Update(fixedDeltaTime);
   
    // Update Time Accumulators for Tweens
    tweenElapsedTime += fixedDeltaTime;
    // Calculate progress based on the fixed accumulation
    // Note: You might need to adjust the divisor (currently 1000.0/fFrameTime in your old code was dynamic)
    // Let's assume you want the tween to last 5 seconds (5.0):
    double progress = tweenElapsedTime / 1000.0f;

    tween.step((float)progress);
    if (tween.isFinished()) {
        tween.seek(0.0f);
        tweenElapsedTime = 0.0f;
    }

	for (auto& ftext : m_ftext)
    {
       if(ftext)ftext->Update((float)fixedDeltaTime);
    }
}
// ------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------
void ArkiGame::Shutdown()
{
    SAFE_DELETE(m_wadViewer);
    SAFE_DELETE(m_fpsPlayer);
	SAFE_DELETE(m_phl1bsp);
    SAFE_DELETE(m_pq3bsp);
	SAFE_DELETE(m_bspLevel);
	SAFE_DELETE(g_HUD);
    SAFE_DELETE(m_spawner);
	SAFE_DELETE(m_bulletManager);

	for (auto& ftext : m_ftext)
    {
        SAFE_DELETE(ftext);
    }

    SAFE_DELETE( eb);
    SAFE_DELETE( emmiter1);
    SAFE_DELETE( es);


    SAFE_RELEASE(m_radialTex)

    SAFE_DELETE(m_sbatch)

    SAFE_DELETE(g_gizmo);
    SAFE_DELETE(m_grid);

    SAFE_DELETE(m_mainMenu);

    SAFE_DELETE( m_player );
    //SAFE_DELETE( m_ball );
    SAFE_DELETE( m_currentLevel );

    CRigidBody::CleanupSharedMesh();

    CArkiBlock::CleanupSharedMesh();

    for (auto e : m_enemies) {
        SAFE_DELETE(e);
	}
    
    for (auto* cliff : m_leftWalls)
    {
		SAFE_DELETE(cliff);
    }
    for (auto* cliff : m_rightWalls)
    {
        SAFE_DELETE(cliff);
    }
    m_leftWalls.clear();
	m_rightWalls.clear();

    for (CRigidBody* obj : m_sceneObjects)// 1. Loop through every object and delete it
    {
        // This calls ~GameObject(), which calls DestroyPhysics(), 
        // which removes the body from Bullet.
        SAFE_DELETE( obj);
    }
    m_sceneObjects.clear();// 2. Clear the vector so it has size 0

	for (auto* powerup : m_powerups)
    {
        SAFE_DELETE(powerup);
    }

    SAFE_DELETE(m_pTextureMgr);

    m_font->Shutdown();
    SAFE_DELETE( m_font);

    SAFE_DELETE(m_pSkybox);
    SAFE_DELETE(m_pCam0);
	SAFE_DELETE(m_pCamEditor);
    //SAFE_RELEASE(pFont);
    //SAFE_RELEASE(pSphereMesh);
    //SAFE_RELEASE(pBoxMesh);
    SAFE_DELETE(m_pBodyMesh);
    SAFE_DELETE(m_pSkullMesh);
    SAFE_DELETE(m_pTeapotMesh);

    ShutdownPhysics();

    ImGui_ImplDX9_Shutdown();
    ImGui_ImplWin32_Shutdown();
    ImGui::DestroyContext();

    xau->Shutdown();
    d3d9->Shutdown();
    Log->Shutdown();

}

// ------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------
void ArkiGame::InitGUI(void)
{
    // Setup Dear ImGui context
    IMGUI_CHECKVERSION();
    ImGui::CreateContext();
    //ImGuiIO& io = ImGui::GetIO();
    //io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;     // Enable Keyboard Controls
    //io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad;      // Enable Gamepad Controls
    //io.ConfigFlags |= ImGuiConfigFlags_DockingEnable;         // IF using Docking Branch
    // Setup Platform/Renderer backends
    ImGui_ImplWin32_Init(d3d9->GetHWND());
    ImGui_ImplDX9_Init(d3d9->GetDevice());
}
// ------------------------------------------------------------------------------------
// physics stuff
// ------------------------------------------------------------------------------------
void ArkiGame::InitPhysics()
{
    btDebugDrawer = new CBulletDebugDrawer(d3d9->GetDevice());

    g_collisionConfiguration = new btDefaultCollisionConfiguration();
    g_dispatcher = new btCollisionDispatcher(g_collisionConfiguration);
    g_broadphase = new btDbvtBroadphase();

    g_solver = new btSequentialImpulseConstraintSolver;
    g_dynamicsWorld = new btDiscreteDynamicsWorld(g_dispatcher, g_broadphase, g_solver, g_collisionConfiguration);
    g_dynamicsWorld->setGravity(btVector3(0, -10, 0));
    g_dynamicsWorld->setDebugDrawer(btDebugDrawer);
    btDebugDrawer->setDebugMode(btIDebugDraw::DBG_DrawWireframe);

    m_floor = new CRigidBody();
    m_floor->InitBox(g_dynamicsWorld, D3DXVECTOR3(64, 2, 2), 0.0f, false);
    m_floor->SetPosition(0, -22, 0);
    m_sceneObjects.push_back(m_floor);    // Add to list so we don't lose track of it

    m_top = new CRigidBody();
    m_top->InitBox(g_dynamicsWorld, D3DXVECTOR3(64, 2, 2), 0.0f, false);
    m_top->SetPosition(0, 22, 0);
    m_sceneObjects.push_back(m_top);    // Add to list so we don't lose track of it

    m_wallL = new CRigidBody();
    m_wallL->InitBox(g_dynamicsWorld, D3DXVECTOR3(2, 44, 2), 0.0f, false);
    m_wallL->SetPosition(-29, 0, 0);
    m_sceneObjects.push_back(m_wallL);    // Add to list so we don't lose track of it

    m_wallR = new CRigidBody();
    m_wallR->InitBox(g_dynamicsWorld, D3DXVECTOR3(2, 44, 2), 0.0f, false);
    m_wallR->SetPosition(29, 0, 0);
    m_sceneObjects.push_back(m_wallR);    // Add to list so we don't lose track of it


}
// ------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------
void ArkiGame::ShutdownPhysics()
{
    // Cleanup in the reverse order of creation/initialization
    //remove the rigidbodies from the dynamics world and delete them
    for (int i = g_dynamicsWorld->getNumCollisionObjects() - 1; i >= 0; i--)
    {
        btCollisionObject* obj = g_dynamicsWorld->getCollisionObjectArray()[i];
        btRigidBody* body = btRigidBody::upcast(obj);
        if (body && body->getMotionState())
        {
            delete body->getMotionState();
        }
        g_dynamicsWorld->removeCollisionObject(obj);
        delete obj;
    }

    
    delete g_dynamicsWorld;
    delete g_solver;
    delete g_broadphase;
    delete g_dispatcher;
    delete g_collisionConfiguration;
    delete btDebugDrawer;
}
// ------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------
void ArkiGame::OnLostDevice()
{
	g_HUD->OnLostDevice();
	if (m_phl1bsp) m_phl1bsp->OnLostDevice();
	if (m_pq3bsp)m_pq3bsp->OnLostDevice();
	if (m_grid)m_grid->OnLostDevice();
	if (m_sbatch)m_sbatch->OnLostDevice();
	if (m_player) m_player->OnLostDevice();
    //if (pFont)pFont->OnLostDevice();
    //if (g_pEffect)g_pEffect->OnLostDevice();
    //SAFE_RELEASE(g_pDSShadow);
    //SAFE_RELEASE(g_pShadowMap);
    //SAFE_RELEASE(g_pTexDef);

}
// ------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------
void ArkiGame::OnResetDevice()
{
	g_HUD->OnResize(d3d9->GetWidth(), d3d9->GetHeight());
    //HRESULT hr;
	if(m_grid)m_grid->OnResetDevice();
	if (m_sbatch)m_sbatch->OnResetDevice();
    if (m_player) m_player->OnResetDevice();
	if (m_pq3bsp) m_pq3bsp->OnResetDevice();
	if (m_phl1bsp) m_phl1bsp->OnResetDevice();

    SetRenderStateDefaults();

    //g_pEffect->SetVector( "g_vLightDiffuse", ( D3DXVECTOR4* )&l0.Diffuse ) ;
    //g_pEffect->SetFloat( "g_fCosTheta", cosf( spot_cam1->GetFov()/2 ) ) ;
    //g_pEffect->SetFloat( "fTheta", ( spot_cam1->GetFov()/2 ) ) ;
}
// ------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------
BOOL ArkiGame::ResetDevice()
{
    OnLostDevice();
    ImGui_ImplDX9_InvalidateDeviceObjects();

    HRESULT hr = d3d9->GetDevice()->Reset(&d3d9->m_d3dpp);
    if (FAILED(hr)) {
        return FALSE; // Reset failed, likely still lost
    }

    ImGui_ImplDX9_CreateDeviceObjects();
    OnResetDevice();

    return TRUE;
}
// ------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------
void ArkiGame::RenderGUI()
{

    //char m_debugString[64];
    const char* formulaItems[] = {
    "Rings",                // 0
    "Waves",                // 1
    "Plasma",               // 2
    "Sierpinski Triangle",  // 3
    "Sierpinski Carpet",    // 4
    "Liquid Grid",          // 5
    "Julia Set",            // 6
    "Mandelbrot Set"        // 7
    };
    int currentSelection = (int)p.formulaType;
    // 1. Start Frame
    ImGui_ImplDX9_NewFrame();
    ImGui_ImplWin32_NewFrame();
    ImGui::NewFrame();
    //ImGui::ShowDemoWindow(); // Show demo window! :)

	//sprintf(m_debugString, "FPS: %.2f", ImGui::GetIO().Framerate);
    ImGui::Begin("Debug Tools");
    //ImGui::SetWindowFontScale(2.0f);
    //ImGui::SetNextWindowSize(ImVec2(-1, -1), ImGuiCond_Always);
    ImGui::Text("FPS: %.3f fps", ImGui::GetIO().Framerate);
	ImGui::Text("Player pos: %.3f %.3f %.3f", m_player->GetPosition().x, m_player->GetPosition().y, m_player->GetPosition().z);

    if (ImGui::CollapsingHeader("ARKANOID"))
    {
        // "Formula"      = Label displayed next to box
        // formulaItems   = The array of strings defined above
        // IM_ARRAYSIZE   = Helper macro to get array count automatically
        if (ImGui::Combo("Formula Type", &currentSelection, formulaItems, IM_ARRAYSIZE(formulaItems)))
        {
            // 3. Update the struct ONLY if the user changed the value
            p.formulaType = currentSelection;
            m_currentLevel->UpdateParameters(p);
            // Optional: Auto-set recommended scales if formula changes
            if (p.formulaType == FORMULA_MANDELBROT) { // Mandelbrot
                p.scaleX = 3.0f / p.cols;
                p.scaleY = 2.5f / p.rows;
            }
            else if (p.formulaType == FORMULA_SIERPINSKI_CARPET)
            {
                p.scaleX = 1.0f;
                p.scaleY = 1.0f;
            }
            else
            {
                p.scaleX = (rand() % 5 + 3) / 10.0f;
                p.scaleY = (rand() % 5 + 3) / 10.0f;
            }
        }
        if (ImGui::Button("Level Generate")) {
            //ResetDevice(); 
           // p = LevelParams::Random(20, 20, p.formulaType);
            // Create a random recipe
            m_currentLevel->GenerateMathLevel(p);
        }
        ImGui::SameLine();
        if (ImGui::Button("Randomize Seed")) {
            p.seed = rand();
            m_currentLevel->UpdateParameters(p);
            m_currentLevel->GenerateMathLevel(p);
        }
        // --------------------------------------------------------
        // OTHER CONTROLS
        // --------------------------------------------------------
        ImGui::DragInt("Rows", &m_currentLevel->m_currentParams.rows, 1, 5, 100);
        ImGui::DragInt("Cols", &m_currentLevel->m_currentParams.cols, 1, 5, 100);

        ImGui::DragInt("Offset X", &m_currentLevel->m_currentParams.offsetX, 1, -15, 15);
        ImGui::DragInt("Offset Y", &m_currentLevel->m_currentParams.offsetY, 1, -15, 15);

        // Sliders allow fine control for your Zoom/Scale
        ImGui::SliderFloat("Scale X", &m_currentLevel->m_currentParams.scaleX, 0.01f, 2.0f);
        ImGui::SliderFloat("Scale Y", &m_currentLevel->m_currentParams.scaleY, 0.01f, 2.0f);

        // Random Seeds are usually big integers, so DragInt is best
        ImGui::DragInt("Seed", &m_currentLevel->m_currentParams.seed);

        if (ImGui::Button("Clean level")) {
            m_currentLevel->ClearLevel();
        }
    }
    if (ImGui::Button("Save ...")) {
        //emmiter1->SaveConfig("config.json");
        //eb->Spawn(512, D3DXVECTOR3(0, 0, 0),10, 60.0f);
        //mymesh->SaveAsOBJ("bodyl_save.obj");
    }
    //if (ImGui::Button("Particles Editor")) {
    //    //emmiter1->SaveConfig("config.json");
    //    //eb->Spawn(512, D3DXVECTOR3(0, 0, 0), 10, 60.0f);
    //    //mymesh->SaveAsOBJ("bodyl_save.obj");
    //}
    if (ImGui::Button("Load Quake3 BSP")) {
		std::wstring filepath = OpenFileDialog(d3d9->GetHWND(), L".bsp\0*.bsp\0");
		m_pq3bsp->Load( g_dynamicsWorld ,filepath);
        // 1. Iterate entities
        for (const auto& ent : m_pq3bsp->GetEntities())
        {
            // 2. Check classname
            if (ent.GetProp("classname") == "info_player_deathmatch")
            {
                // 3. Get Origin (Automatically scaled and swizzled to match your world)
                D3DXVECTOR3 spawnPos = ent.GetOrigin(m_pq3bsp->SCALE_FACTOR); // Use same scale as InitGraphics

                // Set Camera
                m_fpsPlayer->SetPosition(spawnPos);
                break;
            }
        }
    }
    if (ImGui::Button("Load HL1 BSP")) {
        std::wstring filepath = OpenFileDialog(d3d9->GetHWND(), L".bsp\0*.bsp\0");
        m_phl1bsp->Load(g_dynamicsWorld, filepath);
        // 1. Iterate entities
        for (const auto& ent : m_phl1bsp->GetEntities())
        {
            if (ent.Get("classname") == "info_player_start")
            {
                // 1. Get Raw Coords (X, Y, Z)
                D3DXVECTOR3 raw = ent.GetVector("origin");

                // 2. Apply Scale and Swizzle (Z-Up -> Y-Up)
                float x = raw.x * m_phl1bsp->SCALE_FACTOR;
                float y = raw.z * m_phl1bsp->SCALE_FACTOR; // Z becomes Y
                float z = raw.y * -m_phl1bsp->SCALE_FACTOR; // Y becomes Z

                // 3. Set Camera
                m_fpsPlayer->SetPosition(D3DXVECTOR3(x,y,z));
                break;
            }
        }
    }
    if (ImGui::Button("Load WAD")) {
        std::wstring filepath = OpenFileDialog(d3d9->GetHWND(), L".wad\0*.wad\0");
		m_wadViewer->OpenWAD(filepath);
		m_viewerOpen = TRUE;
    }
	if (ImGui::Button("Back to Menu"))
    {
        //eb->Spawn(256, D3DXVECTOR3(0, 0, 0), 5, 30.0f);
        m_gameState = STATE_MENU;//
    }

    if (ImGui::Checkbox("Debug Draw", &m_debugdraw))
    {
    }
    if (ImGui::Checkbox("Entities", &m_pEntitiesDraw))
    {
    }

    if (ImGui::Checkbox("Particles", &m_pfxdraw))
    {
    }

    ImGui::End();

    m_wadViewer->Draw(&m_viewerOpen);

    switch (m_gameState)
    {
        case STATE_MENU:
        {
            m_isPaused = true;

            MenuResult res = m_mainMenu->Render();
            if (res == MENU_START_GAME_ARKI)    
            {
                m_gameState = STATE_PLAYING_ARKI;
                m_isPaused = false;
				m_isEditorMode = false;
                m_isFPSMode = false;

			}
            if (res == MENU_START_GAME_FPS)
            {
                m_gameState = STATE_PLAYING_FPS;
                m_isPaused = false;
                m_isEditorMode = false;
				m_isFPSMode = true;
            }

            if (res == MENU_OPEN_EDITOR)
            {
                m_gameState = STATE_EDITOR;
				m_isEditorMode = true;
                m_isPaused = false;
                m_isFPSMode = false;

            }
            if (res == MENU_OPEN_SETTINGS) m_gameState = STATE_SETTINGS;
            if (res == MENU_EXIT_GAME)     PostQuitMessage(0);
            break;
        }
        case STATE_PLAYING_ARKI || STATE_PLAYING_FPS:
        {
            if (GetAsyncKeyState(VK_ESCAPE) & 0x8000) m_gameState = STATE_PAUSED;
            
			break;
        }

        case STATE_PAUSED: // Render game background even if paused
        {
            m_isPaused = true;
            // 2. If Paused, Draw Overlay
            //if (m_gameState == STATE_PAUSED)
            //{
                ImGui::OpenPopup("PauseMenu"); // Force popup open
                // Centered Window
                //ImGuiIO& io = ImGui::GetIO();
                //ImGui::SetNextWindowPos(ImVec2(io.DisplaySize.x * 0.5f, io.DisplaySize.y * 0.5f), ImGuiCond_Always, ImVec2(0.5f, 0.5f));

                // Centered Popup
                ImGui::SetNextWindowPos(ImGui::GetMainViewport()->GetCenter(), ImGuiCond_Always, ImVec2(0.5f, 0.5f));

                if (ImGui::BeginPopupModal("PauseMenu", NULL, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoTitleBar))
                {
                    ImGui::SetWindowFontScale(2.0f);

                    ImGui::Text("GAME PAUSED");
                    ImGui::Separator();

                    if (ImGui::Button("RESUME", ImVec2(-1, 45))) { 
                        //m_gameState = STATE_PLAYING; 
                        ImGui::CloseCurrentPopup();
                        m_isPaused = false;
                    }
                    ImGui::Spacing();

                    if (ImGui::Button("MAIN MENU", ImVec2(-1, 45))) { m_gameState = STATE_MENU; ImGui::CloseCurrentPopup(); }

                    ImGui::EndPopup();
                }
            //}
            break;
        }
        case STATE_EDITOR:
        {
            // 1. Check if the level is busy
            bool isBusy = (m_bspLevel->GetState() == BS_BUILDING_BSP || m_bspLevel->GetState() == BS_CALC_RAD);
            float progress = 0;
            ImGui::SetNextWindowSize(ImVec2(-1, -1), ImGuiCond_Always);
            ImGui::Begin("Level Editor (Placeholder)");
            ImGui::Text("Editor controls:");
            ImGui::Spacing();

			ImGui::Text("ALT + LMB Orbit camera");
			ImGui::Text("ALT + RMB Zoom in/out");
			ImGui::Text("ALT + MMB Pan camera");
			
            if (ImGui::Button("Build BSP"))
            {
				//if (m_bspLevel)m_bspLevel->StartBackgroundBuild();
            }
            if (isBusy)
            {
                progress = m_bspLevel->GetProgress(); // Your atomic float (0.0 to 1.0)
            }
            char overlay[32];
            sprintf_s(overlay, "%.0f%%", progress * 100.0f);

            ImGui::ProgressBar(progress, ImVec2(300.0f, 0.0f), overlay);
            //if (ImGui::Button("Build Radiosity"))
            //{
                //if (m_bspLevel)m_bspLevel->BuildRAD();
            //}

			ImGui::Spacing();
            if (ImGui::Button("Back")) m_gameState = STATE_MENU;
            ImGui::End();

            RenderObjectProperties();

             break;
        }
        case STATE_SETTINGS:
        {
            ImGui::Begin("Settings");
            ImGui::Text("Volume");
            static float vol = 0.5f;
            ImGui::SliderFloat("##vol", &vol, 0.0f, 1.0f);

            ImGui::Spacing();
            if (ImGui::Button("Back")) m_gameState = STATE_MENU;
            ImGui::End();
            break;
        }
    }

    // 3. Render
    ImGui::Render();
    ImGui_ImplDX9_RenderDrawData(ImGui::GetDrawData());
}
// ------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------
void ArkiGame::RenderEditorScene()
{
    D3DXMATRIXA16 matWorld;
    D3DXMatrixIdentity(&matWorld);
    d3d9->GetDevice()->SetTransform(D3DTS_WORLD, &matWorld);

    m_pCamEditor->Render(d3d9->GetDevice(), fDeltaTime);
    m_pSkybox->DrawSkybox(d3d9->GetDevice(), m_pCamEditor->GetViewMatrix(), fDeltaTime);


    // Render grid, gizmos, selection boxes, etc.
    if(m_grid && m_debugdraw)m_grid->Render(d3d9->GetDevice());


    for (auto obj : m_sceneObjects)
    {   
		    obj->Render(d3d9->GetDevice());
    }

    D3DXVECTOR3 camPos = D3DXVECTOR3( (FLOAT)m_pCamEditor->GetPosition().x(),(FLOAT)m_pCamEditor->GetPosition().y(),(FLOAT)m_pCamEditor->GetPosition().z());
    //if (m_bspLevel)m_bspLevel->Render(d3d9->GetDevice(), camPos);
    if (m_pq3bsp)m_pq3bsp->Render();
    if (m_phl1bsp)m_phl1bsp->Render();
    if (m_pEntitiesDraw)
    {
        if (m_phl1bsp)m_phl1bsp->RenderEntities(g_gizmo);
    }


    if(g_gizmo)g_gizmo->Render(d3d9->GetDevice());
}

void ArkiGame::RenderFPSGameScene()
{
    D3DXMATRIXA16 matWorld, matRot, matScale, matTrans;

    D3DMATERIAL9 sphereMaterial;
    InitMaterialS(sphereMaterial, 1.0f, 1.0f, 0.5f, 0.5f);
    d3d9->GetDevice()->SetMaterial(&sphereMaterial);

    m_val = (float)tween.peek();
    D3DXMatrixIdentity(&matWorld);
    D3DXMatrixIdentity(&matRot);
    D3DXMatrixRotationY(&matRot, m_val);
    d3d9->GetDevice()->SetTransform(D3DTS_WORLD, &matWorld);

    D3DXMatrixTranslation(&matWorld, 22, 10, 0);
    D3DXMatrixMultiply(&matWorld, &matRot, &matWorld);
    //d3d9->GetDevice()->SetTransform(D3DTS_WORLD, &matWorld);
    //m_pTeapotMesh->Render(m_pSkybox->GetTexture(), m_pSkybox->GetRotationY());

    D3DXMatrixTranslation(&matWorld, 22, 8, 0);
    D3DXMatrixMultiply(&matWorld, &matRot, &matWorld);
    //d3d9->GetDevice()->SetTransform(D3DTS_WORLD, &matWorld);
    //m_pSkullMesh->Render(m_pSkybox->GetTexture(), m_pSkybox->GetRotationY());

    D3DXMatrixTranslation(&matWorld, 0, 1, 0);
    D3DXMatrixMultiply(&matWorld, &matRot, &matWorld);
    //d3d9->GetDevice()->SetTransform(D3DTS_WORLD, &matWorld);
    //m_pBodyMesh->Render(m_pSkybox->GetTexture(), m_pSkybox->GetRotationY());

    D3DXVECTOR3 camPos = D3DXVECTOR3((FLOAT)m_pCamEditor->GetPosition().x(), (FLOAT)m_pCamEditor->GetPosition().y(), (FLOAT)m_pCamEditor->GetPosition().z());
    //if (m_bspLevel)m_bspLevel->Render(d3d9->GetDevice(), camPos);
    if (m_pq3bsp)m_pq3bsp->Render();
	if (m_phl1bsp)m_phl1bsp->Render();

}

void ArkiGame::RenderArkiGameScene()
{
    d3d9->GetDevice()->SetRenderState(D3DRS_FOGENABLE, TRUE);
    d3d9->GetDevice()->SetRenderState(D3DRS_FOGTABLEMODE, D3DFOG_EXP2);
    d3d9->GetDevice()->SetRenderState(D3DRS_FOGCOLOR, D3DCOLOR_XRGB(15, 55, 255));
    d3d9->GetDevice()->SetRenderState(D3DRS_FOGSTART, *(DWORD*)(&fFogStart));
    d3d9->GetDevice()->SetRenderState(D3DRS_FOGEND, *(DWORD*)(&fFogEnd));
    d3d9->GetDevice()->SetRenderState(D3DRS_FOGDENSITY, *(DWORD*)(&fFogDensity));

    for (auto obj : m_sceneObjects)
    {
        obj->Render(d3d9->GetDevice());
    }

    for (auto& cliff : m_rightWalls)
    {
        cliff->Render(d3d9->GetDevice());
    }
    for (auto& cliff : m_leftWalls)
    {
        cliff->Render(d3d9->GetDevice());
    }
    d3d9->GetDevice()->SetRenderState(D3DRS_FOGENABLE, FALSE);
    // m_ball->Render(d3d9->GetDevice(), m_pSkybox->GetTexture(), m_pCam0->GetViewMatrix(), m_pSkybox->GetRotationY());
    m_bulletManager->Render(d3d9->GetDevice());
    m_currentLevel->Render(d3d9->GetDevice(), m_font, NULL, m_pSkybox->GetRotationX());
    m_font->RenderBatch(d3d9->GetDevice());

    m_player->Render(m_pSkybox, m_pCam0->GetViewMatrix());
    m_spawner->Render(d3d9->GetDevice());

    for (auto& powerup : m_powerups)
    {
        powerup->Render(d3d9->GetDevice(), m_font, m_pSkybox->GetTexture(), m_pSkybox->GetRotationX());
    }
    for (auto& ftext : m_ftext)
    {
        if (ftext)ftext->Render(m_font);
    }
    d3d9->GetDevice()->SetRenderState(D3DRS_ZENABLE, FALSE);
    m_font->RenderBatch(d3d9->GetDevice());
    d3d9->GetDevice()->SetRenderState(D3DRS_ZENABLE, TRUE);
    float healthPercent = (1.0f / m_player->m_maxHealth) * m_player->m_health;
    if (g_HUD)g_HUD->Render(d3d9->GetDevice(), m_sbatch, healthPercent, 12343);


}

// ------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------
void ArkiGame::Render(double dt)
{ 
    D3DXMATRIXA16 matWorld;
    HRESULT hr = d3d9->GetDevice()->TestCooperativeLevel();
    if (hr == D3DERR_DEVICELOST)
    {
        // The device has been lost but cannot be reset at this time.
        // So wait until it can be reset.
        Sleep(100);
        return;
    }
    if (hr == D3DERR_DEVICENOTRESET)
    {
        // The device is lost but ready to be reset.
        if (!ResetDevice()) 
        {
            // If reset fails, return and try again next frame.
            return;
       }
    }

    d3d9->GetDevice()->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, D3DCOLOR_ARGB(255, 0, 90, 90), 1.0f, 0L);
    if (SUCCEEDED(d3d9->GetDevice()->BeginScene()))
    {
        m_pCam0->Render(d3d9->GetDevice());
        m_pSkybox->DrawSkybox(d3d9->GetDevice(), m_pCam0->GetViewMatrix(), fDeltaTime);
        xau->SetListenerPos(m_pCam0->GetPosition());
        d3d9->GetDevice()->LightEnable(0, TRUE);
        d3d9->GetDevice()->SetRenderState(D3DRS_LIGHTING, TRUE);

        switch(m_gameState)
        {
            case STATE_PLAYING_ARKI:
                m_pCam0->fovY = D3DX_PI / 4.0f;
                RenderArkiGameScene();
                break;
            case STATE_PLAYING_FPS:
				m_pCam0->fovY = 90.0f;
                RenderArkiGameScene();
                RenderFPSGameScene();
                break;
			case STATE_EDITOR:
                RenderEditorScene();
				break;
            default:
                break;
		}
            /*for (auto e : m_enemies) {
				e->Render(d3d9->GetDevice());
            }*/

            D3DXMatrixIdentity(&matWorld);
            d3d9->GetDevice()->SetTransform(D3DTS_WORLD, &matWorld);

            //if (m_sbatch )
            //{
            //    m_sbatch->Begin(m_pCam0->GetViewMatrix(), SORT_BACK_TO_FRONT);
            //    {
            //        // Draw something with sprite batch
            //        m_sbatch->Draw(m_radialTex, btVector3(0, 1, 0));

            //        //emmiter1->Render(m_sbatch, m_radialTex);
            //        //eb->Render(m_sbatch, m_radialTex);
            //        //es->Render(m_sbatch, m_radialTex);
            //    }
            //    m_sbatch->End();
            //}
   
        

        if (m_debugdraw)
        {
            D3DXMatrixIdentity(&matWorld);
            d3d9->GetDevice()->SetTransform(D3DTS_WORLD, &matWorld);

            g_dynamicsWorld->debugDrawWorld();
            btDebugDrawer->Draw();

            // Draw the line using Bullet's debug drawer or DX9 Line
            btVector3 from(vNear.x, vNear.y, vNear.z);
            btVector3 to(vFar.x, vFar.y, vFar.z);
            g_dynamicsWorld->getDebugDrawer()->drawLine(from, to, btVector3(1, 0, 0)); // Red Line
            D3DXMatrixIdentity(&matWorld);
            d3d9->GetDevice()->SetTransform(D3DTS_WORLD, &matWorld);

        }

        d3d9->GetDevice()->SetRenderState(D3DRS_ZENABLE, FALSE);
        RenderGUI();
        d3d9->GetDevice()->SetRenderState(D3DRS_ZENABLE, TRUE);


        d3d9->GetDevice()->EndScene(); 
    }
    hr = d3d9->GetDevice()->Present(0, 0, 0, 0);
}

void ArkiGame::ProcessEditorInput(double dt)
{
    POINT mpoint;
    // (Use a flag to ensure single-click, or GetAsyncKeyState logic)
    static bool wasPressed = false;

    // CRITICAL FIX: Check if ImGui wants to capture the mouse
    ImGuiIO& io = ImGui::GetIO();
    if (io.WantCaptureMouse)
    {
        // ImGui is handling mouse input (dialog, sliders, buttons, etc.)
        // Don't process selection or gizmo input
        wasPressed = (GetAsyncKeyState(VK_LBUTTON) & 0x8000) != 0;
        return;
    }

    if (GetAsyncKeyState(VK_MENU) & 0x8000)
    {
        if (GetAsyncKeyState(VK_LBUTTON) & 0x8000)
        {
        
            m_pCamEditor->Orbit(-mouseDeltaX * 0.002f, -mouseDeltaY * 0.002f);
        }
        if (GetAsyncKeyState(VK_MBUTTON) & 0x8000)
        {
            m_pCamEditor->Pan(mouseDeltaX * 1.002f, mouseDeltaY * 1.002f);
        }
        if (GetAsyncKeyState(VK_RBUTTON) & 0x8000)
        {
            //m_pCamEditor->Zoom(mouseDeltaX * 1.002f, mouseDeltaY * 1.002f);
			scrollAmount += mouseDeltaY * 0.1002f;
        }
    }
    else
    {
        // Additional input processing (e.g., GUI) can go here
        // Check Left Mouse Button Click
        bool isPressed = (GetAsyncKeyState(VK_LBUTTON) & 0x8000) != 0;
        // Get Mouse Position (Windows API)
        GetCursorPos(&mpoint);
        ScreenToClient(d3d9->GetHWND(), &mpoint); // Convert to window local coordinates
        btVector3 hitPoint;
        btRigidBody* hitBody = nullptr;
        bool raycastHit = RaycastFromMouse(mpoint.x, mpoint.y, hitPoint, hitBody);

            // 3. Convert to Bullet Vectors
            btVector3 rayFrom(vNear.x, vNear.y, vNear.z);
            btVector3 rayTo(vFar.x, vFar.y, vFar.z);

            //if (isPressed && !wasPressed)
            //{
            if (g_gizmo)
            {
                // STATE MACHINE LOGIC
                if (g_gizmo->IsActive())
                {
                    // State A: User is holding the mouse down and moving an axis
                    g_gizmo->UpdateDrag(vNear, rayDir);
                    _print(L"Draggggggg\n");
                }
                else
                {
                    // State B: User is just moving mouse around
                    // Check if we are hovering over an arrow (to highlight it yellow)
                    g_gizmo->UpdateHover(vNear, rayDir);
                }
            }

            if (isPressed && !wasPressed) 
            {
                if (raycastHit) 
                {
                    if (g_selected) g_selected->m_isSelected = false; // Deselect old
                    //_print(L"Clicked at: X=%.2f Y=%.2f Z=%.2f\n", hitPoint.x(), hitPoint.y(), hitPoint.z());
                    _print(L"Hit Body: %p\n", hitBody);
                    // Search logic (In real engine, store CGameObject* in UserPointer of btRigidBody)
                    for (auto obj : m_sceneObjects)
                    {
                        if (obj->m_rigidBody == hitBody)
                        {
                            g_selected = obj;
                            g_selected->m_isSelected = true;
                            g_gizmo->SetTarget(g_selected);
                            g_gizmo->OnMouseDown(vNear, rayDir);

                            break;
                        }
                    }

                }
                else
                {
                    // Clicked void, deselect
                    if (g_selected) g_selected->m_isSelected = false;
                    g_selected = NULL;
                    g_gizmo->SetTarget(NULL);
                }
                // 2. Check Gizmo First
                //if (g_gizmo && g_selected)
                //{
                //    g_gizmo->OnMouseDown(D3DXVECTOR3(rayFrom.x(), rayFrom.y(), rayFrom.z()), D3DXVECTOR3(rayTo.x(), rayTo.y(), rayTo.z()));
                //    if (g_gizmo->IsActive()) return; // We are dragging the gizmo, don't select new object
                //}
            }
			if (wasPressed && !isPressed)
            {
                // Mouse Released
                if (g_gizmo && g_gizmo->IsActive())
                {
                    g_gizmo->OnMouseUp();
                }
            }
            //    if (hitBody && hitBody->getUserPointer())
            //    {
            //        PhysicsData* data = (PhysicsData*)hitBody->getUserPointer();

            //        // --- INTERACTION LOGIC ---
            //        if (data->type == TYPE_BLOCK)
            //        {
            //            _print(L"Clicked on a BLOCK!\n");
            //            // Example: Destroy block on click (Editor Mode?)
            //            CArkiBlock* block = (CArkiBlock*)data->pObject;
            //           // block->m_pendingDestruction = true;
            //        }
            //        else if (data->type == TYPE_PLAYER)
            //        {
            //            _print(L"Clicked on PLAYER!\n");
            //        }
                
            
            
        
        wasPressed = isPressed;

    }
    // Zoom in/out
    m_pCamEditor->Zoom(scrollAmount * 2.0f); // Multiplier for speed
    
}

void ArkiGame::ProcessArkiInput(double dt)
{
	static bool spaceWasPressed = false;
    float moveSpeed = 15.0f * (float)dt;

     m_inputLeft = ( GetAsyncKeyState(VK_LEFT) & 0x8000) || (GetAsyncKeyState('A') & 0x8000);
     m_inputRight = ( GetAsyncKeyState(VK_RIGHT) & 0x8000) || (GetAsyncKeyState('D') & 0x8000);
    
    bool spacePressed = (GetAsyncKeyState(VK_SPACE) & 0x8000) != 0;

    if (spacePressed && !spaceWasPressed)
    {
        btTransform trans;
        m_player->m_pBody->getMotionState()->getWorldTransform(trans);

        m_player->LaunchBalls();
        // Load a MONO sound (Stereo sounds don't pan well in 3D)

        // Fireball is to the RIGHT (5,0,0)
        btVector3 firePos = trans.getOrigin();
        // This will sound like it's coming from the RIGHT speaker
        xau->Play3D("shoot1", firePos );

        //m_enemies.push_back(new CFlyingEnemy(g_dynamicsWorld, D3DXVECTOR3(5, 15, 0), m_pTeapotMesh));
		//CArkiBomb* newBomb;
       // newBomb = new CArkiBomb(g_dynamicsWorld, D3DXVECTOR3((FLOAT)trans.getOrigin().getX(), (FLOAT)trans.getOrigin().getY(), (FLOAT)trans.getOrigin().getZ()), m_pCam0);
       // m_sceneObjects.push_back(newBomb);

        //m_pCam0->Shake(1.0f, 1.0f);
        //fs->Spawn(D3DXVECTOR3(firePos.getX(), firePos.getY(), firePos.getY()), L"xXXXx");
        //m_ball->Launch();
        //isBallActive = true;
    }
	spaceWasPressed = spacePressed;
    //if(isBallActive && GetAsyncKeyState(VK_SPACE))
    //{
	//	m_player->Shoot();
    //}
}
void ArkiGame::ProcessFPSInput(double dt)
{
    //static bool spaceWasPressed = false;
    //float moveSpeed = 15.0f * (float)dt;
    //if (GetAsyncKeyState(VK_CONTROL) & 0x8000) {
        m_pCam0->RotateFPS(-mouseDeltaY * 0.002f, -mouseDeltaX * 0.002f);
    //}
        if (m_fpsPlayer)m_fpsPlayer->Update(dt);
    // Keyboard Movement
    //if (GetAsyncKeyState('W') & 0x8000) m_pCam0->MoveLocal(moveSpeed, 0, 0);
    //if (GetAsyncKeyState('S') & 0x8000) m_pCam0->MoveLocal(-moveSpeed, 0, 0);
    //if (GetAsyncKeyState('A') & 0x8000) m_pCam0->MoveLocal(0, -moveSpeed, 0);
    //if (GetAsyncKeyState('D') & 0x8000) m_pCam0->MoveLocal(0, moveSpeed, 0);
}
// ------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------
void ArkiGame::CheckCollisions(btDiscreteDynamicsWorld* dynamicsWorld)
{
    int numManifolds = dynamicsWorld->getDispatcher()->getNumManifolds();

    for (int i = 0; i < numManifolds; i++)
    {
        btPersistentManifold* contactManifold = dynamicsWorld->getDispatcher()->getManifoldByIndexInternal(i);

        // 1. Get the two bodies involved
        const btCollisionObject* obA = contactManifold->getBody0();
        const btCollisionObject* obB = contactManifold->getBody1();

        // 2. Check if they are actually touching
        // (Bullet keeps manifolds for objects strictly close to each other too)
        int numContacts = contactManifold->getNumContacts();
        if (numContacts == 0) continue;

        // 3. Retrieve our custom data
        PhysicsData* dataA = (PhysicsData*)obA->getUserPointer();
        PhysicsData* dataB = (PhysicsData*)obB->getUserPointer();

        if (!dataA || !dataB) continue; // Safety check

        // 4. Logic: Did Ball hit Block?
        // We don't know if A is Ball or B is Ball, so we check both combinations
        PhysicsData* ballData = nullptr;
        PhysicsData* blockData = nullptr;
        PhysicsData* playerData = nullptr;
        PhysicsData* enemyData = nullptr;

        PhysicsData* playerBulletData = nullptr;
        PhysicsData* enemyBulletData = nullptr;
        PhysicsData* wallData = nullptr;
        PhysicsData* powerupData = nullptr;

        if (dataA->type == TYPE_BALL) ballData = dataA;
        if (dataB->type == TYPE_BALL) ballData = dataB;

        if (dataA->type == TYPE_WALL) wallData = dataA;
        if (dataB->type == TYPE_WALL) wallData = dataB;

        if (dataA->type == TYPE_BLOCK) blockData = dataA;
        if (dataB->type == TYPE_BLOCK) blockData = dataB;

        if (dataA->type == TYPE_PLAYER) playerData = dataA;
        if (dataB->type == TYPE_PLAYER) playerData = dataB;

        if (dataA->type == TYPE_ENEMY) enemyData = dataA;
        if (dataB->type == TYPE_ENEMY) enemyData = dataB;

        if (dataA->type == TYPE_PLAYER_BULLET) playerBulletData = dataA;
        if (dataB->type == TYPE_PLAYER_BULLET) playerBulletData = dataB;

        if (dataA->type == TYPE_ENEMY_BULLET) enemyBulletData = dataA;
        if (dataB->type == TYPE_ENEMY_BULLET) enemyBulletData = dataB;

        if (dataA->type == TYPE_POWERUP) powerupData = dataA;
        if (dataB->type == TYPE_POWERUP) powerupData = dataB;

        // --- SCENARIO : Ball hit enemy ---
        if (ballData && enemyData)
        {
            CFlyingEnemy* pEne = (CFlyingEnemy*)enemyData->pObject;
           // CArkiBall* pBall = (CArkiBall*)ballData->pObject;

            if (!pEne->m_isDead)
            {
                pEne->m_isDead = true;
            }
        }

        // --- SCENARIO : Ball hit Block ---
        if (ballData && blockData)
        {
            CArkiBlock* pBlock = (CArkiBlock*)blockData->pObject;
			CArkiBall* pBall = (CArkiBall*)ballData->pObject;

            if (!pBlock->m_isDestroyed && !pBlock->m_pendingDestruction)
            {
                pBlock->m_pendingDestruction = true;

                btTransform balltrans;
                pBall->m_pBody->getMotionState()->getWorldTransform(balltrans);
                // Get Block Position
                btTransform trans = pBlock->m_pBody->getWorldTransform();

                // Fireball is to the RIGHT (5,0,0)
                btVector3 firePos = balltrans.getOrigin();
                // This will sound like it's coming from the RIGHT speaker
                xau->Play3D("knock", firePos);

                //PlayAudioFromMemory(GenerateMutedKnock());
                // Play Sound here...
                // Add Score here...
                if (PullFromDeck())
                {

                    PowerupType type = PickWeightedType();
                    CArkiPowerup* newPowerup;
                    CArkiBomb* newBomb;

                    switch (type)
                    {
                    case PU_HEALTH:
                    case PU_FLOOR:
                    case PU_GUN:
                    case PU_SPEED:
                    case PU_BALL:
                    case PU_MISSILE:
                    case PU_LASER:
                        newPowerup = new CArkiPowerup(g_dynamicsWorld, trans.getOrigin(), type);
                        m_powerups.push_back(newPowerup);
                        break;
                    case PU_BOMB:
                        newBomb = new CArkiBomb(g_dynamicsWorld, D3DXVECTOR3((FLOAT)trans.getOrigin().getX(), (FLOAT)trans.getOrigin().getY(), (FLOAT)trans.getOrigin().getZ()), m_pCam0);
                        m_sceneObjects.push_back(newBomb);
                        break;

                    }
                }
				
                FloatingText3D* ftext = new FloatingText3D();
                ftext->Spawn(D3DXVECTOR3((FLOAT)trans.getOrigin().getX(), (FLOAT)trans.getOrigin().getY(), (FLOAT)trans.getOrigin().getZ()), std::to_wstring(pBlock->scoreValue));
				m_ftext.push_back(ftext);

            }
        }
        if (playerBulletData && blockData)
        {
            CArkiBlock* pBlock = (CArkiBlock*)blockData->pObject;
            CArkiBullet* pBullet = (CArkiBullet*)playerBulletData->pObject;


            if (!pBlock->m_isDestroyed && !pBlock->m_pendingDestruction)
            {
                pBlock->m_pendingDestruction = true;
                // Play Sound here...
                // Add Score here...
               
            }
            if (!pBullet->m_markForDelete)
            {
                pBullet->m_markForDelete = true; // Destroy Bullet
            }

            // 20% Chance to spawn powerup
            //if (rand() % 100 < 20)
            if (PullFromDeck())
            {
                // Get Block Position
                btTransform trans = ((CArkiBlock*)dataB->pObject)->m_pBody->getWorldTransform();

                // Random Type
                //PowerupType type = (PowerupType)(rand() % 5); // Assuming you have 3 types defined
                PowerupType type = PickWeightedType();
                CArkiPowerup* newPowerup;
                CArkiBomb* newBomb;

                switch (type)
                {
                case PU_HEALTH:
                case PU_FLOOR:
                case PU_GUN:
                case PU_SPEED:
                case PU_BALL:
                case PU_MISSILE:
                case PU_LASER:
                    newPowerup = new CArkiPowerup(g_dynamicsWorld, trans.getOrigin(), type);
                    m_powerups.push_back(newPowerup);
                    break;
                case PU_BOMB:
                    newBomb = new CArkiBomb(g_dynamicsWorld, D3DXVECTOR3((FLOAT)trans.getOrigin().getX(), (FLOAT)trans.getOrigin().getY(), (FLOAT)trans.getOrigin().getZ()), m_pCam0);
                    m_sceneObjects.push_back(newBomb);
                    break;
               
                }

            }
          
        }
        if (enemyBulletData && wallData)
        {
            CEnemyBullet* pBullet = (CEnemyBullet*)enemyBulletData->pObject;
            if (!pBullet->m_markForDelete)
            {
                pBullet->m_markForDelete = true; // Destroy Bullet
            }
        }
        if (enemyBulletData && blockData)
        {
            CArkiBlock* pBlock = (CArkiBlock*)blockData->pObject;
            CEnemyBullet* pBullet = (CEnemyBullet*)enemyBulletData->pObject;

            if (!pBlock->m_isDestroyed && !pBlock->m_pendingDestruction)
            {
                pBlock->m_pendingDestruction = true;
                // Play Sound here...
                // Add Score here...
            }
            if (!pBullet->m_markForDelete)
            {
                pBullet->m_markForDelete = true; // Destroy Bullet
            }

            // 20% Chance to spawn powerup
            //if (rand() % 100 < 20)
            if (PullFromDeck())
            {
                // Get Block Position
                btTransform trans = ((CArkiBlock*)dataB->pObject)->m_pBody->getWorldTransform();

                // Random Type
                //PowerupType type = (PowerupType)(rand() % 5); // Assuming you have 3 types defined
                PowerupType type = PickWeightedType();
                CArkiPowerup* newPowerup;
                //CArkiBomb* newBomb;
                switch (type)
                {
                case PU_HEALTH:
                case PU_FLOOR:
                case PU_GUN:
                case PU_SPEED:
                case PU_BALL:
                case PU_MISSILE:
                case PU_LASER:
                    newPowerup = new CArkiPowerup(g_dynamicsWorld, trans.getOrigin(), type);
                    m_powerups.push_back(newPowerup);
                    break;
                case PU_BOMB:
                    //newBomb = new CArkiBomb(g_dynamicsWorld, D3DXVECTOR3((FLOAT)trans.getOrigin().getX(), (FLOAT)trans.getOrigin().getY(), (FLOAT)trans.getOrigin().getZ()), m_pCam0);
                    //m_sceneObjects.push_back(newBomb);
                    break;
                }
            }
        }

		if (powerupData && playerData)
        {
            CArkiPowerup* pPowerup = (CArkiPowerup*)powerupData->pObject;
            if (!pPowerup->m_collected)
            {
                pPowerup->m_collected = true;
                pPowerup->m_markForDelete = true;

                btTransform trans;
                pPowerup->m_pBody->getMotionState()->getWorldTransform(trans);
                // Fireball is to the RIGHT (5,0,0)
                btVector3 firePos = trans.getOrigin();
                // This will sound like it's coming from the RIGHT speaker
                xau->Play3D("powerup", firePos);

				//PlayAudioFromMemory(GeneratePowerupSound());
                // Apply effect based on type
                switch (pPowerup->m_type)
                {
                    case PU_BALL:
						m_player->AddBall();
                        break;
                    case PU_HEALTH:
						m_player->Heal(20); // Heal 20 health
                        break;
                    //case POWERUP_SHIELD:
                    //    pPlayer->ActivateShield(10.0f); // 10 seconds
                    //    break;
                    //case POWERUP_DOUBLE_POINTS:
                    //    pPlayer->ActivateDoublePoints(15.0f); // 15 seconds
                    //    break;
                    //case POWERUP_MULTI_BALL:
                    //    m_ball->SpawnAdditionalBalls(2); // Spawn 2 extra balls
                    //    break;
                }
            }
        }
        // --- SCENARIO 2: Ball hit Player (The "English" Effect) ---
        if (ballData && playerData)
        {
            // Optional: Adjust bounce angle based on where it hit the paddle
            // This gives the player control over the ball

            CArkiBall* pBall = (CArkiBall*)ballData->pObject;
            CArkiPlayer* pPlayer = (CArkiPlayer*)playerData->pObject;

            btTransform ballTrans = pBall->m_pBody->getWorldTransform();
            btTransform playerTrans = pPlayer->m_pBody->getWorldTransform();

            float ballX = static_cast<float>(ballTrans.getOrigin().getX());
            float playerX = static_cast<float>(playerTrans.getOrigin().getX());

            float diff = ballX - playerX; // -1 (left side) to +1 (right side)

            // Add horizontal velocity based on hit position
            btVector3 velocity = pBall->m_pBody->getLinearVelocity();
            velocity.setX(velocity.getX() + (diff * 5.0f)); // 5.0f is the "spin" strength
            pBall->m_pBody->setLinearVelocity(velocity);

            btTransform trans;
            pBall->m_pBody->getMotionState()->getWorldTransform(trans);
            // Fireball is to the RIGHT (5,0,0)
            btVector3 firePos = trans.getOrigin();
            // This will sound like it's coming from the RIGHT speaker
            xau->Play3D("ding", firePos);


        }
    }
}
// Returns the PhysicsData* of the object hit, or nullptr if nothing hit
PhysicsData* ArkiGame::RaycastWithMask(btDynamicsWorld* world, btVector3 start, btVector3 end, int rayGroup, int rayMask)
{
    // 1. Create the Callback
    btCollisionWorld::ClosestRayResultCallback rayCallback(start, end);

    // 2. Apply the Filters
    // GROUP: Identity of the ray (usually COL_BULLET or a specific sensor group)
    rayCallback.m_collisionFilterGroup = rayGroup;

    // MASK: What the ray is allowed to hit
    rayCallback.m_collisionFilterMask = rayMask;

    // 3. Perform the Ray Test
    world->rayTest(start, end, rayCallback);

    // 4. Check Results
    if (rayCallback.hasHit())
    {
        // We hit something!
        btRigidBody* body = (btRigidBody*)btRigidBody::upcast(rayCallback.m_collisionObject);
        if (body)
        {
            // Optional: Get Hit Position and Normal
            // btVector3 hitPoint = rayCallback.m_hitPointWorld;
            // btVector3 hitNormal = rayCallback.m_hitNormalWorld;

            // Return the User Data (So we know if we hit a Block or a Player)
            return (PhysicsData*)body->getUserPointer();
        }
    }

    return nullptr; // Hit nothing (or nothing matching the mask)
}
// Helper to Cast a Ray from Camera into World
// Returns true if we hit something, and fills 'hitPoint' and 'pBody'
bool ArkiGame::RaycastFromMouse(int mouseX, int mouseY, btVector3& outHitPoint, btRigidBody*& outBody)
{
    if (!m_pCam0 || !g_dynamicsWorld) return false;

    // 1. Get Viewport, Projection, and View Matrices
    D3DVIEWPORT9 vp;
    d3d9->GetDevice()->GetViewport(&vp);

    D3DXMATRIX matProj, matView, matWorld;
    d3d9->GetDevice()->GetTransform(D3DTS_PROJECTION, &matProj);
    d3d9->GetDevice()->GetTransform(D3DTS_VIEW, &matView);
    D3DXMatrixIdentity(&matWorld); // We pick in World Space, so World Matrix is Identity

    // 2. Unproject Near and Far points
    // This creates a line segment starting at the camera lens (Near) 
    // and ending at the far clip plane (Far) passing through the mouse cursor.
    D3DXVECTOR3 vMouse((float)mouseX, (float)mouseY, 0.0f);

    // z=0 for near plane, z=1 for far plane
    vMouse.z = 0.0f;
    D3DXVec3Unproject(&vNear, &vMouse, &vp, &matProj, &matView, &matWorld);

    vMouse.z = 1.0f;
    D3DXVec3Unproject(&vFar, &vMouse, &vp, &matProj, &matView, &matWorld);

    // 3. Convert to Bullet Vectors
    btVector3 rayFrom(vNear.x, vNear.y, vNear.z);
    btVector3 rayTo(vFar.x, vFar.y, vFar.z);
    // Direction = Destination - Source
    rayDir = vFar - vNear;
    D3DXVec3Normalize(&rayDir, &rayDir);
    // 4. Perform Ray Test in Bullet Physics
    btCollisionWorld::ClosestRayResultCallback rayCallback(rayFrom, rayTo);
    g_dynamicsWorld->rayTest(rayFrom, rayTo, rayCallback);

    if (rayCallback.hasHit())
    {
        outHitPoint = rayCallback.m_hitPointWorld;
        outBody = (btRigidBody*)btRigidBody::upcast(rayCallback.m_collisionObject);
        return true;
    }

    return false;
}

void ArkiGame::RenderObjectProperties()
{
    if (!g_selected) return;

    ImGui::SetNextWindowSize(ImVec2(300, 400), ImGuiCond_FirstUseEver);
    if (ImGui::Begin("Object Properties", NULL, ImGuiWindowFlags_AlwaysAutoResize))
    {
        ImGui::Text("Selected Object");
        ImGui::Separator();

        // Object Name Section
        ImGui::TextColored(ImVec4(1.0f, 0.5f, 0.0f, 1.0f), "Object Name");
        static char nameBuffer[128] = { 0 };

        // Copy name to buffer on first display
        if (nameBuffer[0] == 0)
        {
            strcpy_s(nameBuffer, sizeof(nameBuffer), g_selected->m_name.c_str());
        }

        if (ImGui::InputText("##name", nameBuffer, sizeof(nameBuffer)))
        {
            g_selected->SetName(std::string(nameBuffer));
        }

        ImGui::Separator();
        // Position Section
        ImGui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "Position");
        static float position[3] = { 0.0f, 0.0f, 0.0f };
        position[0] = g_selected->m_position.x;
        position[1] = g_selected->m_position.y;
        position[2] = g_selected->m_position.z;

        if (ImGui::DragFloat("X##pos", &position[0], 0.1f))
            g_selected->SetPosition(position[0], position[1], position[2]);
        if (ImGui::DragFloat("Y##pos", &position[1], 0.1f))
            g_selected->SetPosition(position[0], position[1], position[2]);
        if (ImGui::DragFloat("Z##pos", &position[2], 0.1f))
            g_selected->SetPosition(position[0], position[1], position[2]);

        ImGui::Spacing();

        // Rotation Section (Euler Angles in Degrees for readability)
        ImGui::TextColored(ImVec4(0.0f, 1.0f, 1.0f, 1.0f), "Rotation");
        float eulerDegrees[3];
        eulerDegrees[0] = D3DXToDegree(g_selected->m_eulerAngles.x);
        eulerDegrees[1] = D3DXToDegree(g_selected->m_eulerAngles.y);
        eulerDegrees[2] = D3DXToDegree(g_selected->m_eulerAngles.z);

        if (ImGui::DragFloat("Yaw##rot", &eulerDegrees[0], 1.0f))
            g_selected->SetRotation(D3DXToRadian(eulerDegrees[0]), D3DXToRadian(eulerDegrees[1]), D3DXToRadian(eulerDegrees[2]));
        if (ImGui::DragFloat("Pitch##rot", &eulerDegrees[1], 1.0f))
            g_selected->SetRotation(D3DXToRadian(eulerDegrees[0]), D3DXToRadian(eulerDegrees[1]), D3DXToRadian(eulerDegrees[2]));
        if (ImGui::DragFloat("Roll##rot", &eulerDegrees[2], 1.0f))
            g_selected->SetRotation(D3DXToRadian(eulerDegrees[0]), D3DXToRadian(eulerDegrees[1]), D3DXToRadian(eulerDegrees[2]));

        ImGui::Spacing();

        // Scale Section
        ImGui::TextColored(ImVec4(1.0f, 0.0f, 1.0f, 1.0f), "Scale");
        static float scale[3] = { 1.0f, 1.0f, 1.0f };
        scale[0] = g_selected->m_scale.x;
        scale[1] = g_selected->m_scale.y;
        scale[2] = g_selected->m_scale.z;

        if (ImGui::DragFloat("Scale X", &scale[0], 0.1f, 0.1f, 100.0f))
            g_selected->m_scale = D3DXVECTOR3(scale[0], scale[1], scale[2]);
        if (ImGui::DragFloat("Scale Y", &scale[1], 0.1f, 0.1f, 100.0f))
            g_selected->m_scale = D3DXVECTOR3(scale[0], scale[1], scale[2]);
        if (ImGui::DragFloat("Scale Z", &scale[2], 0.1f, 0.1f, 100.0f))
            g_selected->m_scale = D3DXVECTOR3(scale[0], scale[1], scale[2]);

        ImGui::Spacing();
        ImGui::Separator();

        // Reset Button
        if (ImGui::Button("Reset Transform"))
        {
            g_selected->SetPosition(0.0f, 0.0f, 0.0f);
            g_selected->SetRotation(0.0f, 0.0f, 0.0f);
            g_selected->m_scale = D3DXVECTOR3(1.0f, 1.0f, 1.0f);
        }
        ImGui::SameLine();
        if (ImGui::Checkbox("Snapping", &m_usesnap))
        {
            g_gizmo->SetSnapping(m_usesnap, 0.1f);
        }
        g_selected->RescaleObject(btVector3(g_selected->m_scale.x, g_selected->m_scale.y, g_selected->m_scale.z));

        ImGui::End();
    }
}

// ---------------------------------------------------------
// 1. INITIALIZATION (Call this in ArkiGame::Init)
// ---------------------------------------------------------
void ArkiGame::InitBagSystem()
{
    // Seed the RNG with hardware entropy (makes it truly random every run)
    std::random_device rd;
    m_rng.seed(rd());

    // Prepare the first bag
    m_deckIndex = 0;
    m_dropDeck.clear();

    // -- CONFIGURATION: 20% Chance --
    // We put 10 items in the bag:
    // 2 are TRUE (Powerup)
    // 8 are FALSE (Nothing)

    m_dropDeck.push_back(true);
    m_dropDeck.push_back(true);

    for (int i = 0; i < 8; i++) {
        m_dropDeck.push_back(false);
    }

    // Shuffle the bag immediately
    std::shuffle(m_dropDeck.begin(), m_dropDeck.end(), m_rng);
}

// ---------------------------------------------------------
// 2. THE BAG LOGIC (Draws a card, reshuffles if empty)
// ---------------------------------------------------------
bool ArkiGame::PullFromDeck()
{
    // 1. Read the result at current index
    bool result = m_dropDeck[m_deckIndex];

    // 2. Move to next card
    m_deckIndex++;

    // 3. If we used all cards, reshuffle the deck!
    if (m_deckIndex >= m_dropDeck.size())
    {
        // Shuffle existing values (2 Trues, 8 Falses) to new positions
        std::shuffle(m_dropDeck.begin(), m_dropDeck.end(), m_rng);
        m_deckIndex = 0;
    }

    return result;
}

// ---------------------------------------------------------
// 3. WEIGHTED TYPE PICKER (Better than rand() % 5)
// ---------------------------------------------------------
PowerupType ArkiGame::PickWeightedType()
{
    // We roll a number 0-100 to decide rarity
    std::uniform_int_distribution<int> dist(0, 100);
    int roll = dist(m_rng);

    // LOGIC:
    // 50% chance for Paddle Increase
    // 30% chance for Laser
    // 15% chance for Sticky
    // 5%  chance for Extra Life

    if (roll < 50) return PU_HEALTH; // Most Common
    roll -= 50;

    if (roll < 30) return PU_BOMB;
    roll -= 30;

    if (roll < 15) return PU_BALL;

    return PU_GUN; // Rarest
}

// ------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------
void ArkiGame::LoadLevel(int levelID)
{
    // 1. Clean up old level
    if (m_pSkybox) {
        delete m_pSkybox;
        m_pSkybox = NULL;
    }
    // 2. Load new level settings
    if (levelID == 1) {
        // m_pSkybox = new CSkybox();
        // m_pSkybox->Init("sky_day.dds");
    }
    else if (levelID == 2) {
        // Maybe this level uses a different procedural sky class?
        // m_pSkybox = new ProceduralSkybox(); // Polymorphism!
    }
}
