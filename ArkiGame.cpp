#include "stdafx.h"
#include "imgui.h"
#include "imgui_impl_win32.h"
#include "imgui_impl_dx9.h"
#include "tweeny.h"
#include "EmbeddedAssets.h" // The file generated by Python
#include "ArkiGame.h"
#include "Sounds.h"

using tweeny::easing;
// Create a tween from 0 to 100 over 100 steps (or milliseconds)
auto tween = tweeny::from(0.0f)
.to(D3DX_PI).during(1000).via(easing::elasticInOutEasing())
.to(0).during(1000).via(easing::elasticInOutEasing());


static double tweenElapsedTime = 0;

// IMPORTANT: Define the static variable in your .cpp file (outside any function)
ID3DXMesh* CArkiBlock::s_pSharedBoxMesh = NULL;


// Helper: Opens a Windows file picker (Wide String Version)
std::wstring OpenFileDialog(HWND owner = NULL)
{
    OPENFILENAMEW ofn;       // Wide structure
    wchar_t szFile[260];     // Wide buffer

    // Initialize buffer
    ZeroMemory(szFile, sizeof(szFile));

    // Initialize OPENFILENAMEW
    ZeroMemory(&ofn, sizeof(ofn));
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = owner;
    ofn.lpstrFile = szFile;
    ofn.lpstrFile[0] = L'\0';
    ofn.nMaxFile = sizeof(szFile) / sizeof(wchar_t); // Size in WCHARs
    ofn.lpstrFilter = L"Arki Level\0*.txt;*.lvl\0All\0*.*\0"; // Wide string literals
    ofn.nFilterIndex = 1;
    ofn.lpstrFileTitle = NULL;
    ofn.nMaxFileTitle = 0;
    ofn.lpstrInitialDir = NULL;
    ofn.Flags = OFN_PATHMUSTEXIST | OFN_FILEMUSTEXIST | OFN_NOCHANGEDIR;

    if (GetOpenFileNameW(&ofn) == TRUE)
    {
        return std::wstring(ofn.lpstrFile);
    }
    return L""; // User cancelled
}

// Helper: Opens a Windows "Save As" file picker (Wide String Version)
std::wstring SaveFileDialog(HWND owner = NULL)
{
    OPENFILENAMEW ofn;
    wchar_t szFile[260];

    ZeroMemory(szFile, sizeof(szFile));

    ZeroMemory(&ofn, sizeof(ofn));
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = owner;
    ofn.lpstrFile = szFile;
    ofn.lpstrFile[0] = L'\0';
    ofn.nMaxFile = sizeof(szFile) / sizeof(wchar_t);
    ofn.lpstrFilter = L"Arki Level\0*.txt;*.lvl\0All\0*.*\0";
    ofn.nFilterIndex = 1;
    ofn.lpstrDefExt = L"txt";

    ofn.Flags = OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT | OFN_NOCHANGEDIR;

    if (GetSaveFileNameW(&ofn) == TRUE)
    {
        return std::wstring(ofn.lpstrFile);
    }
    return L"";
}


// ------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------
ArkiGame::ArkiGame()
{
    m_pSkybox = NULL;
	m_pCam0 = NULL;
    m_pCamEditor = NULL;
    m_pBodyMesh = NULL;
    m_pSkullMesh = NULL;
    m_pTeapotMesh = NULL;
    eb = NULL;
    emmiter1 = NULL;
    es = NULL;
    m_val = 0.0f;
	m_ball = NULL;
	m_player = NULL;
    isBallActive = FALSE;
    m_isPaused = FALSE;

    m_mainMenu = new CMainMenu();
    m_gameState = STATE_MENU; // Start in menu

	m_grid = new CGrid();

	m_inputLeft = false;
	m_inputRight = false;
	m_isEditorMode = false;

    g_selected = NULL;
    g_gizmo = NULL;
}

void ArkiGame::LoadLevel(int levelID)
{
    // 1. Clean up old level
    if (m_pSkybox) {
        delete m_pSkybox;
        m_pSkybox = NULL;
    }
    // 2. Load new level settings
    if (levelID == 1) {
        // m_pSkybox = new CSkybox();
        // m_pSkybox->Init("sky_day.dds");
    }
    else if (levelID == 2) {
        // Maybe this level uses a different procedural sky class?
        // m_pSkybox = new ProceduralSkybox(); // Polymorphism!
    }
}
// ------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------
bool ArkiGame::Init()
{
    // logger initialization
    if (!Log->Initialize())
        return FALSE;

    // d3d stuff
    if (!d3d9->Initialize())
        return FALSE;

    RAWINPUTDEVICE Rid[1];
    Rid[0].usUsagePage = HID_USAGE_PAGE_GENERIC;
    Rid[0].usUsage = HID_USAGE_GENERIC_MOUSE;
    Rid[0].dwFlags = RIDEV_INPUTSINK;
    Rid[0].hwndTarget = d3d9->GetHWND();
    RegisterRawInputDevices(Rid, 1, sizeof(Rid[0]));

    InitGUI();
    InitPhysics();

    m_pCam0 = new CQuatCamera();
    m_pCam0->MoveLocal(-50, 0, 0);

    m_pCamEditor = new COrbitCamera();

    m_pSkybox = new CSkybox(d3d9->GetDevice(), L".\\null.dds");

    m_font = new CSpriteFont();
    m_font->InitFromMemory(d3d9->GetDevice(),
        FONT_DATA, FONT_DATA_SIZE,
        FONT_TEXTURE, FONT_TEXTURE_SIZE);

    m_pBodyMesh = new CXMesh(d3d9->GetDevice(), L".\\body.x");
    m_pSkullMesh = new CXMesh(d3d9->GetDevice(), L".\\skullocc.x");
    m_pTeapotMesh = new CXMesh(d3d9->GetDevice(), L".\\teapot.x");

    //D3DXCreateSphere(d3d9->GetDevice(), 0.5f, 24, 32, &pSphereMesh, NULL);
    //D3DXCreateBox(d3d9->GetDevice(), 50, 2, 50, &pBoxMesh, NULL);
    CArkiBlock::InitSharedMesh(d3d9->GetDevice());
	CRigidBody::InitSharedMesh(d3d9->GetDevice());
    m_currentLevel = new CArkiLevel(g_dynamicsWorld);
    //m_currentLevel->GenerateRandomLevel(20, 18, false);
    m_currentLevel->GenerateMathLevel(20, 18);
    m_ball = new CArkiBall(g_dynamicsWorld, d3d9->GetDevice(), D3DXVECTOR3(0, -7, 0), 0.3f, 20.0f);
    m_player = new CArkiPlayer(g_dynamicsWorld, D3DXVECTOR3(0, -16, 0));

    DWORD dwShaderFlags = D3DXFX_NOT_CLONEABLE;
    #if defined( DEBUG ) || defined( _DEBUG )
        // Set the D3DXSHADER_DEBUG flag to embed debug information in the shaders.
        // Setting this flag improves the shader debugging experience, but still allows 
        // the shaders to be optimized and to run exactly the way they will run in 
        // the release configuration of this program.
        dwShaderFlags |= D3DXSHADER_DEBUG;
    #endif
    #ifdef DEBUG_VS
        dwShaderFlags |= D3DXSHADER_FORCE_VS_SOFTWARE_NOOPT;
    #endif
    #ifdef DEBUG_PS
        dwShaderFlags |= D3DXSHADER_FORCE_PS_SOFTWARE_NOOPT;
    #endif


	m_grid->Create(d3d9->GetDevice(), 100.0f, 1.0f);
    g_gizmo = new CGizmo(d3d9->GetDevice());

	m_sbatch = new CSpriteBatch();
	m_sbatch->Init(d3d9->GetDevice());

    CreateRadialGradientTexture(
        d3d9->GetDevice(),
        256,
        256,
        D3DCOLOR_ARGB(255,255, 255, 255), // Inner color (white)
        D3DCOLOR_ARGB(0,0, 0, 0),       // Outer color (black)
		&m_radialTex);


	emmiter1 = new ParticleEmitter(D3DXVECTOR3(0.0f, 50.0f, 0.0f), 150.0f);
	eb = new BoidEmitter(2048);
	es = new SphereEmitter(btVector3(0.0f, 15.0f, 0.0f), 5.0f, 330.0f);
	es->SetSurfaceOnly(true);
    SetRenderStateDefaults();

    // Create 3 segments (A, B, C)
    float segmentHeight = 25.0f;
    float currentVirtualY = 0.0f; // Global counter for noise

    for (int i = 0; i < 3; i++)
    {
        float startY = -100.0f + (i * segmentHeight); 

        // Left Wall
        CArkiCliffTreadmill* l = new CArkiCliffTreadmill(g_dynamicsWorld, d3d9->GetDevice(), segmentHeight, startY, -25.0f, false, currentVirtualY);
        m_leftWalls.push_back(l);

        // Right Wall
        CArkiCliffTreadmill* r = new CArkiCliffTreadmill(g_dynamicsWorld, d3d9->GetDevice(), segmentHeight, startY, 25.0f, true, currentVirtualY + 500.0f);
        m_rightWalls.push_back(r);
    }

    InitBagSystem();
   

    _log(L"Initializing Done\n");


    return true;
}

void ArkiGame::SetRenderStateDefaults()
{
    // Light 0: Directional light from above
    InitLight(m_LightDefault, D3DLIGHT_DIRECTIONAL, 0.0f, -0.6f, -0.3f, 1.0f, 1.0f, 1.0f);
    d3d9->GetDevice()->SetLight(0, &m_LightDefault);
    d3d9->GetDevice()->LightEnable(0, TRUE);

    d3d9->GetDevice()->SetRenderState(D3DRS_COLORVERTEX, TRUE);
    d3d9->GetDevice()->SetRenderState(D3DRS_EMISSIVEMATERIALSOURCE, D3DMCS_MATERIAL);
    d3d9->GetDevice()->SetRenderState(D3DRS_AMBIENTMATERIALSOURCE, D3DMCS_MATERIAL);
    d3d9->GetDevice()->SetRenderState(D3DRS_DIFFUSEMATERIALSOURCE, D3DMCS_MATERIAL);
    d3d9->GetDevice()->SetRenderState(D3DRS_SPECULARMATERIALSOURCE, D3DMCS_MATERIAL);
    d3d9->GetDevice()->SetRenderState(D3DRS_ZENABLE, TRUE);
    d3d9->GetDevice()->SetRenderState(D3DRS_CULLMODE, D3DCULL_NONE);
    d3d9->GetDevice()->SetRenderState(D3DRS_FILLMODE, D3DFILL_SOLID);
    d3d9->GetDevice()->SetRenderState(D3DRS_AMBIENT, D3DCOLOR_XRGB(32, 32, 64));
    d3d9->GetDevice()->SetRenderState(D3DRS_LIGHTING, TRUE);
    d3d9->GetDevice()->SetRenderState(D3DRS_SPECULARENABLE, TRUE);
}
// ------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------
void ArkiGame::Run()
{
    fFrameTime = (double)m_Timer.GetElapsedTime();
    fDeltaTime = (double)fFrameTime / 1000.0f;

	Update(fDeltaTime);

	if (m_isEditorMode)
		ProcessEditorInput(fDeltaTime);
	else
        ProcessGameInput(fDeltaTime);


	Render(fDeltaTime);

    // Reset accumulators
    mouseDeltaX = 0;
    mouseDeltaY = 0;
	scrollAmount = 0.0f;
}

// ------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------
void ArkiGame::Update(double dt)
{
    if (m_isPaused) return;
    // Clamp huge spikes (e.g. if you dragged the window or hit a breakpoint)
    if (fDeltaTime > MAX_FRAME_TIME) fDeltaTime = MAX_FRAME_TIME;

    // Add to accumulator
    g_accumulator += fDeltaTime;
    // Consume accumulator in fixed chunks
    // While we have enough accumulated time to run a physics step...
    while (g_accumulator >= FIXED_DT)
    {
        FixedUpdate(FIXED_DT);
        g_accumulator -= FIXED_DT;
    }

}

void ArkiGame::UpdateWalls(float dt)
{
    float scrollSpeed = 3.0f;
    float killY = -50.0f; // Point where wall is fully off-screen

    // ---------------------------------------------------------
    // STEP 1: MOVE EVERYTHING FIRST
    // ---------------------------------------------------------
    for (int i = 0; i < m_leftWalls.size(); i++) {
        m_leftWalls[i]->Scroll(dt, scrollSpeed);
    }
    for (int i = 0; i < m_rightWalls.size(); i++) {
        m_rightWalls[i]->Scroll(dt, scrollSpeed);
    }
    // ---------------------------------------------------------
    // STEP 2: CHECK RECYCLING (Now positions are synchronized)
    // ---------------------------------------------------------
    // Check Left Walls
    for (int i = 0; i < m_leftWalls.size(); i++)
    {
        CArkiCliffTreadmill* wall = m_leftWalls[i];

        if (wall->m_currentY < killY)
        {
            int topIndex = (i == 0) ? m_leftWalls.size() - 1 : i - 1;
            CArkiCliffTreadmill* topWall = m_leftWalls[topIndex];

            // topWall has already moved this frame, so this calculation is safe
            float newY = topWall->m_currentY + topWall->m_height;
            wall->Regenerate(newY, topWall->m_topVirtualY);
        }
    }
    // Check Right Walls
    for (int i = 0; i < m_rightWalls.size(); i++)
    {
        CArkiCliffTreadmill* wall = m_rightWalls[i];

        if (wall->m_currentY < killY)
        {
            int topIndex = (i == 0) ? m_rightWalls.size() - 1 : i - 1;
            CArkiCliffTreadmill* topWall = m_rightWalls[topIndex];

            float newY = topWall->m_currentY + topWall->m_height;
            wall->Regenerate(newY, topWall->m_topVirtualY);
        }
    }
}

// ------------------------------------------------------------------------------------
// This function runs exactly at 60Hz (or whatever FIXED_DT is)
// ------------------------------------------------------------------------------------
void ArkiGame::FixedUpdate(double fixedDeltaTime)
{
    // Bullet Physics
    // We pass '1' as maxSubSteps because we are manually controlling the loop 
    // using our accumulator. We force Bullet to take exactly one step of fixedDeltaTime.
        UpdateWalls(fixedDeltaTime);

    if (g_dynamicsWorld) {
        g_dynamicsWorld->stepSimulation((btScalar)fixedDeltaTime, 1, (btScalar)fixedDeltaTime);
    }
    // Update Logic / Particles
    if (emmiter1) emmiter1->Update((float)fixedDeltaTime);
    if (eb) eb->Update((float)fixedDeltaTime);
    if (es) es->Update((float)fixedDeltaTime);

    if (m_ball && isBallActive)m_ball->UpdateLogic();
	if (m_player) m_player->Update((float)fixedDeltaTime, m_inputLeft, m_inputRight);
	if (m_currentLevel) m_currentLevel->Update();

    CheckCollisions(g_dynamicsWorld);

    // 4. Cleanup (Actually delete the bullets now that physics is done using them)
    if (m_player) m_player->CleanupBullets(); 
    if (m_currentLevel) m_currentLevel->CleanupBlocks();

    // Update Powerups (Check bounds)
    for (int i = 0; i < m_powerups.size(); i++)
    {
        CArkiPowerup* p = m_powerups[i];
        float y = static_cast<float>(p->m_pBody->getWorldTransform().getOrigin().getY());

        // If it falls off the bottom of the screen (-15.0f depending on your cam)
        if (y < -25.0f || p->m_markForDelete)
        {
            g_dynamicsWorld->removeRigidBody(p->m_pBody);
            delete p;
            m_powerups.erase(m_powerups.begin() + i);
            i--;
        }
    }
    //m_leftWall->Animate(dt, 10.0f);
    // Update Time Accumulators for Tweens
    tweenElapsedTime += fixedDeltaTime;
    // Calculate progress based on the fixed accumulation
    // Note: You might need to adjust the divisor (currently 1000.0/fFrameTime in your old code was dynamic)
    // Let's assume you want the tween to last 5 seconds (5.0):
    double progress = tweenElapsedTime / 1000.0f;

    tween.step((float)progress);
    if (tween.isFinished()) {
        tween.seek(0.0f);
        tweenElapsedTime = 0.0f;
    }
}
// ------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------
void ArkiGame::Shutdown()
{
    SAFE_DELETE( eb);
    SAFE_DELETE( emmiter1);
    SAFE_DELETE( es);


    SAFE_RELEASE(m_radialTex)

    SAFE_DELETE(m_sbatch)

    SAFE_DELETE(g_gizmo);
    SAFE_DELETE(m_grid);

    SAFE_DELETE(m_mainMenu);

    SAFE_DELETE( m_player );
    SAFE_DELETE( m_ball );
    SAFE_DELETE( m_currentLevel );

    CRigidBody::CleanupSharedMesh();

    CArkiBlock::CleanupSharedMesh();


    for (auto* cliff : m_leftWalls)
    {
		SAFE_DELETE(cliff);
    }
    for (auto* cliff : m_rightWalls)
    {
        SAFE_DELETE(cliff);
    }
    m_leftWalls.clear();
	m_rightWalls.clear();

    for (CRigidBody* obj : m_sceneObjects)// 1. Loop through every object and delete it
    {
        // This calls ~GameObject(), which calls DestroyPhysics(), 
        // which removes the body from Bullet.
        delete obj;
    }
    m_sceneObjects.clear();// 2. Clear the vector so it has size 0

	for (auto* powerup : m_powerups)
    {
        SAFE_DELETE(powerup);
    }


    m_font->Shutdown();
    SAFE_DELETE( m_font);

    SAFE_DELETE(m_pSkybox);
    SAFE_DELETE(m_pCam0);
	SAFE_DELETE(m_pCamEditor);
    //SAFE_RELEASE(pFont);
    //SAFE_RELEASE(pSphereMesh);
    //SAFE_RELEASE(pBoxMesh);
    SAFE_DELETE(m_pBodyMesh);
    SAFE_DELETE(m_pSkullMesh);
    SAFE_DELETE(m_pTeapotMesh);

    ShutdownPhysics();

    ImGui_ImplDX9_Shutdown();
    ImGui_ImplWin32_Shutdown();
    ImGui::DestroyContext();

    d3d9->Shutdown();
    Log->Shutdown();

}

// ------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------
void ArkiGame::InitGUI(void)
{
    // Setup Dear ImGui context
    IMGUI_CHECKVERSION();
    ImGui::CreateContext();
    //ImGuiIO& io = ImGui::GetIO();
    //io.ConfigFlags |= ImGuiConfigFlags_NavEnableKeyboard;     // Enable Keyboard Controls
    //io.ConfigFlags |= ImGuiConfigFlags_NavEnableGamepad;      // Enable Gamepad Controls
    //io.ConfigFlags |= ImGuiConfigFlags_DockingEnable;         // IF using Docking Branch
    // Setup Platform/Renderer backends
    ImGui_ImplWin32_Init(d3d9->GetHWND());
    ImGui_ImplDX9_Init(d3d9->GetDevice());
}
// ------------------------------------------------------------------------------------
// physics stuff
// ------------------------------------------------------------------------------------
void ArkiGame::InitPhysics()
{
    btDebugDrawer = new CBulletDebugDrawer(d3d9->GetDevice());

    g_collisionConfiguration = new btDefaultCollisionConfiguration();
    g_dispatcher = new btCollisionDispatcher(g_collisionConfiguration);
    g_broadphase = new btDbvtBroadphase();

    g_solver = new btSequentialImpulseConstraintSolver;
    g_dynamicsWorld = new btDiscreteDynamicsWorld(g_dispatcher, g_broadphase, g_solver, g_collisionConfiguration);
    g_dynamicsWorld->setGravity(btVector3(0, -10, 0));
    g_dynamicsWorld->setDebugDrawer(btDebugDrawer);
    btDebugDrawer->setDebugMode(btIDebugDraw::DBG_DrawWireframe);

    //m_ball = new CRigidBody();
    //m_ball->m_position = D3DXVECTOR3(0, 15, 0);
    //m_ball->InitSphere(g_dynamicsWorld, 0.5f, 5.0f, true);
    //m_sceneObjects.push_back(m_ball);
    m_floor = new CRigidBody();
    m_floor->InitBox(g_dynamicsWorld, D3DXVECTOR3(64, 2, 2), 0.0f, false);
    m_floor->SetPosition(0, -22, 0);
    m_sceneObjects.push_back(m_floor);    // Add to list so we don't lose track of it

    m_top = new CRigidBody();
    m_top->InitBox(g_dynamicsWorld, D3DXVECTOR3(64, 2, 2), 0.0f, false);
    m_top->SetPosition(0, 22, 0);
    m_sceneObjects.push_back(m_top);    // Add to list so we don't lose track of it

    m_wallL = new CRigidBody();
    m_wallL->InitBox(g_dynamicsWorld, D3DXVECTOR3(2, 44, 2), 0.0f, false);
    m_wallL->SetPosition(-29, 0, 0);
    m_sceneObjects.push_back(m_wallL);    // Add to list so we don't lose track of it

    m_wallR = new CRigidBody();
    m_wallR->InitBox(g_dynamicsWorld, D3DXVECTOR3(2, 44, 2), 0.0f, false);
    m_wallR->SetPosition(29, 0, 0);
    m_sceneObjects.push_back(m_wallR);    // Add to list so we don't lose track of it


}
// ------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------
void ArkiGame::ShutdownPhysics()
{
    // Cleanup in the reverse order of creation/initialization
    //remove the rigidbodies from the dynamics world and delete them
    for (int i = g_dynamicsWorld->getNumCollisionObjects() - 1; i >= 0; i--)
    {
        btCollisionObject* obj = g_dynamicsWorld->getCollisionObjectArray()[i];
        btRigidBody* body = btRigidBody::upcast(obj);
        if (body && body->getMotionState())
        {
            delete body->getMotionState();
        }
        g_dynamicsWorld->removeCollisionObject(obj);
        delete obj;
    }

    
    delete g_dynamicsWorld;
    delete g_solver;
    delete g_broadphase;
    delete g_dispatcher;
    delete g_collisionConfiguration;
    delete btDebugDrawer;
}
// ------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------
void ArkiGame::OnLostDevice()
{
	//if (m_grid)m_grid->OnLostDevice();
	if (m_sbatch)m_sbatch->OnLostDevice();
	if (m_ball) m_ball->OnDeviceLost();
    //if (pFont)pFont->OnLostDevice();
    //if (g_pEffect)g_pEffect->OnLostDevice();
    //SAFE_RELEASE(g_pDSShadow);
    //SAFE_RELEASE(g_pShadowMap);
    //SAFE_RELEASE(g_pTexDef);

}
// ------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------
void ArkiGame::OnResetDevice()
{
    //HRESULT hr;
	//if(m_grid)m_grid->OnResetDevice();
	if (m_sbatch)m_sbatch->OnResetDevice();
    if (m_ball) m_ball->OnDeviceReset(d3d9->GetDevice());

    SetRenderStateDefaults();

    //g_pEffect->SetVector( "g_vLightDiffuse", ( D3DXVECTOR4* )&l0.Diffuse ) ;
    //g_pEffect->SetFloat( "g_fCosTheta", cosf( spot_cam1->GetFov()/2 ) ) ;
    //g_pEffect->SetFloat( "fTheta", ( spot_cam1->GetFov()/2 ) ) ;
}
// ------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------
BOOL ArkiGame::ResetDevice()
{
    OnLostDevice();
    ImGui_ImplDX9_InvalidateDeviceObjects();

    HRESULT hr = d3d9->GetDevice()->Reset(&d3d9->m_d3dpp);
    if (FAILED(hr)) {
        return FALSE; // Reset failed, likely still lost
    }

    ImGui_ImplDX9_CreateDeviceObjects();
    OnResetDevice();

    return TRUE;
}
// ------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------
void ArkiGame::RenderGUI()
{
    // 1. Start Frame
    ImGui_ImplDX9_NewFrame();
    ImGui_ImplWin32_NewFrame();
    ImGui::NewFrame();
    //ImGui::ShowDemoWindow(); // Show demo window! :)
    ImGui::Begin("Debug Tools");
    //ImGui::SetWindowFontScale(2.0f);

    ImGui::Text("FPS: %.3f fps", ImGui::GetIO().Framerate);
    if (ImGui::Button("Reset Level")) {
        //ResetDevice(); 
		//m_currentLevel->GenerateFractalLevel(20, 18);
		m_currentLevel->GenerateFractalLevel(20, 18);

    }
    if (ImGui::Button("Save Settings")) {
        //emmiter1->SaveConfig("config.json");
        eb->Spawn(512, D3DXVECTOR3(0, 0, 0),10, 60.0f);
        //mymesh->SaveAsOBJ("bodyl_save.obj");
    }
    if (ImGui::Button("Load ...")) {
        //emmiter1->SaveConfig("config.json");
        //eb->Spawn(512, D3DXVECTOR3(0, 0, 0),10, 60.0f);
        //mymesh->SaveAsOBJ("bodyl_save.obj");
    }
	if (ImGui::Button("Back to Menu"))
    {
        //eb->Spawn(256, D3DXVECTOR3(0, 0, 0), 5, 30.0f);
        m_gameState = STATE_MENU;//
    }

    if (ImGui::Checkbox("Debug Draw", &m_debugdraw))
    {
        // Optional: Run code only when clicked
        // e.g. Play a sound or reset something
    }
    if (ImGui::Checkbox("Particles", &m_pfxdraw))
    {
    }

    ImGui::End();


    switch (m_gameState)
    {
        case STATE_MENU:
        {
            m_isPaused = true;

            MenuResult res = m_mainMenu->Render(d3d9->GetDevice());
            if (res == MENU_START_GAME)    
            {
                m_gameState = STATE_PLAYING;
                m_isPaused = false;
				m_isEditorMode = false;
			}
            if (res == MENU_OPEN_EDITOR)
            {
                m_gameState = STATE_EDITOR;
				m_isEditorMode = true;
                m_isPaused = false;
            }
            if (res == MENU_OPEN_SETTINGS) m_gameState = STATE_SETTINGS;
            if (res == MENU_EXIT_GAME)     PostQuitMessage(0);
            break;
        }
        case STATE_PLAYING:
        {
            if (GetAsyncKeyState(VK_ESCAPE) & 0x8000) m_gameState = STATE_PAUSED;
            
			break;
        }

        case STATE_PAUSED: // Render game background even if paused
        {
            m_isPaused = true;
            // 2. If Paused, Draw Overlay
            //if (m_gameState == STATE_PAUSED)
            //{
                ImGui::OpenPopup("PauseMenu"); // Force popup open
                // Centered Window
                ImGuiIO& io = ImGui::GetIO();
                //ImGui::SetNextWindowPos(ImVec2(io.DisplaySize.x * 0.5f, io.DisplaySize.y * 0.5f), ImGuiCond_Always, ImVec2(0.5f, 0.5f));

                // Centered Popup
                ImGui::SetNextWindowPos(ImGui::GetMainViewport()->GetCenter(), ImGuiCond_Always, ImVec2(0.5f, 0.5f));

                if (ImGui::BeginPopupModal("PauseMenu", NULL, ImGuiWindowFlags_AlwaysAutoResize | ImGuiWindowFlags_NoTitleBar))
                {
                    ImGui::SetWindowFontScale(2.0f);

                    ImGui::Text("GAME PAUSED");
                    ImGui::Separator();

                    if (ImGui::Button("RESUME", ImVec2(-1, 45))) { 
                        m_gameState = STATE_PLAYING; 
                        ImGui::CloseCurrentPopup();
                        m_isPaused = false;
                    }
                    ImGui::Spacing();

                    if (ImGui::Button("MAIN MENU", ImVec2(-1, 45))) { m_gameState = STATE_MENU; ImGui::CloseCurrentPopup(); }

                    ImGui::EndPopup();
                }
            //}
            break;
        }
        case STATE_EDITOR:
        {
            ImGui::SetNextWindowSize(ImVec2(-1, -1), ImGuiCond_Always);
            ImGui::Begin("Level Editor (Placeholder)");
            ImGui::Text("Editor controls:");
            ImGui::Spacing();

			ImGui::Text("ALT + LMB Orbit camera");
			ImGui::Text("ALT + RMB Zoom in/out");
			ImGui::Text("ALT + MMB Pan camera");
			
			ImGui::Spacing();
            if (ImGui::Button("Back")) m_gameState = STATE_MENU;
            ImGui::End();

            RenderObjectProperties();
            break;
        }
        case STATE_SETTINGS:
        {
            ImGui::Begin("Settings");
            ImGui::Text("Volume");
            static float vol = 0.5f;
            ImGui::SliderFloat("##vol", &vol, 0.0f, 1.0f);

            ImGui::Spacing();
            if (ImGui::Button("Back")) m_gameState = STATE_MENU;
            ImGui::End();
            break;
        }
    }

    // 3. Render
    ImGui::Render();
    ImGui_ImplDX9_RenderDrawData(ImGui::GetDrawData());
}
// ------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------
void ArkiGame::RenderEditorScene()
{
    D3DXMATRIXA16 matWorld;
    m_pCamEditor->Render(d3d9->GetDevice(), fDeltaTime);
    m_pSkybox->DrawSkybox(d3d9->GetDevice(), m_pCamEditor->GetViewMatrix(), fDeltaTime);


    // Render grid, gizmos, selection boxes, etc.
    if(m_grid)m_grid->Render(d3d9->GetDevice());


    for (auto obj : m_sceneObjects)
    {   
		    obj->Render(d3d9->GetDevice());
    }





    if(g_gizmo)g_gizmo->Render(d3d9->GetDevice());

}
// ------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------
void ArkiGame::Render(double dt)
{ 
    D3DXMATRIXA16 matWorld, matRot, matScale, matTrans;
    HRESULT hr = d3d9->GetDevice()->TestCooperativeLevel();
    if (hr == D3DERR_DEVICELOST)
    {
        // The device has been lost but cannot be reset at this time.
        // So wait until it can be reset.
        Sleep(100);
        return;
    }
    if (hr == D3DERR_DEVICENOTRESET)
    {
        // The device is lost but ready to be reset.
        if (!ResetDevice()) 
        {
            // If reset fails, return and try again next frame.
            return;
       }
    }

    d3d9->GetDevice()->Clear(0, NULL, D3DCLEAR_TARGET | D3DCLEAR_ZBUFFER, D3DCOLOR_ARGB(255, 0, 90, 90), 1.0f, 0L);
    if (SUCCEEDED(d3d9->GetDevice()->BeginScene()))
    {

        if (m_isEditorMode) 
        {

            RenderEditorScene();
        }
        else
        {
            m_pCam0->Render(d3d9->GetDevice(), fDeltaTime);
            m_pSkybox->DrawSkybox(d3d9->GetDevice(), m_pCam0->GetViewMatrix(), fDeltaTime);

            D3DXMatrixIdentity(&matWorld);
            d3d9->GetDevice()->SetTransform(D3DTS_WORLD, &matWorld);

            d3d9->GetDevice()->SetTexture(0, NULL);
            d3d9->GetDevice()->LightEnable(0, TRUE);
            d3d9->GetDevice()->SetRenderState(D3DRS_LIGHTING, TRUE);

            //m_floor->Render(d3d9->GetDevice());
            //m_wallL->Render(d3d9->GetDevice());
            //m_wallR->Render(d3d9->GetDevice());

            for (auto& cliff : m_rightWalls)
            {
                cliff->Render(d3d9->GetDevice());
            }
            for (auto& cliff : m_leftWalls)
            {
                cliff->Render(d3d9->GetDevice());
            }

            D3DMATERIAL9 sphereMaterial;
            InitMaterialS(sphereMaterial, 1.0f, 1.0f, 0.5f, 0.5f);
            d3d9->GetDevice()->SetMaterial(&sphereMaterial);

            m_val = tween.peek();
            D3DXMatrixIdentity(&matWorld);
            D3DXMatrixIdentity(&matRot);
            D3DXMatrixRotationY(&matRot, m_val);

            D3DXMatrixTranslation(&matWorld, 22, 10, 0);
            D3DXMatrixMultiply(&matWorld, &matRot, &matWorld);
            d3d9->GetDevice()->SetTransform(D3DTS_WORLD, &matWorld);
            //m_pTeapotMesh->Render(m_pSkybox->GetTexture(), m_pSkybox->GetRotationY());

            D3DXMatrixTranslation(&matWorld, 22, 8, 0);
            D3DXMatrixMultiply(&matWorld, &matRot, &matWorld);
            d3d9->GetDevice()->SetTransform(D3DTS_WORLD, &matWorld);
            //m_pSkullMesh->Render(m_pSkybox->GetTexture(), m_pSkybox->GetRotationY());

            D3DXMatrixTranslation(&matWorld, 22, 0, 0);
            D3DXMatrixMultiply(&matWorld, &matRot, &matWorld);
            d3d9->GetDevice()->SetTransform(D3DTS_WORLD, &matWorld);
            //m_pBodyMesh->Render(m_pSkybox->GetTexture(), m_pSkybox->GetRotationY());

            m_ball->Render(d3d9->GetDevice(), m_pSkybox->GetTexture(), m_pCam0->GetViewMatrix(), m_pSkybox->GetRotationY());
            m_currentLevel->Render(d3d9->GetDevice(), m_font);
            m_player->Render(d3d9->GetDevice());

            D3DXMatrixIdentity(&matWorld);
            d3d9->GetDevice()->SetTransform(D3DTS_WORLD, &matWorld);


			for (auto& powerup : m_powerups)
            {
                powerup->Render(d3d9->GetDevice(), m_font);
            }

            if (m_sbatch && m_pfxdraw)
            {
                m_sbatch->Begin(m_pCam0->GetViewMatrix());
                {
                    // Draw something with sprite batch
                    m_sbatch->Draw(m_radialTex, btVector3(0, 1, 0));

                    emmiter1->Render(m_sbatch, m_radialTex);
                    eb->Render(m_sbatch, m_radialTex);
                    es->Render(m_sbatch, m_radialTex);
                }
                m_sbatch->End();
            }

            m_font->RenderBatch(d3d9->GetDevice());

        }
        //// 1. Get the raw vertex data from the emitter
        //eb->GetRenderData(renderBuffer);
        //// 2. Pass that data to your renderer
        //pr->Draw(eb->GetRenderData());

        if (m_debugdraw)
        {
            g_dynamicsWorld->debugDrawWorld();
            btDebugDrawer->Draw();

            // Draw the line using Bullet's debug drawer or DX9 Line
            btVector3 from(vNear.x, vNear.y, vNear.z);
            btVector3 to(vFar.x, vFar.y, vFar.z);
            g_dynamicsWorld->getDebugDrawer()->drawLine(from, to, btVector3(1, 0, 0)); // Red Line
        
        }

        d3d9->GetDevice()->SetRenderState(D3DRS_ZENABLE, FALSE);
        RenderGUI();
        d3d9->GetDevice()->SetRenderState(D3DRS_ZENABLE, TRUE);

        d3d9->GetDevice()->EndScene(); 
    }
    hr = d3d9->GetDevice()->Present(0, 0, 0, 0);

}

// ------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------
void RenderStats()
{
    //// Разная статистика
    //D3DCOLOR dwColor = D3DCOLOR_ARGB(180, 235, 255, 255);
    //D3DCOLOR dwAlertColor = D3DCOLOR_ARGB(250, 255, 100, 100);

    //btVector3 cp = cam0->GetPosition();

    //RECT rc = { 10,10,100,100 };
    //TCHAR szText[MAX_PATH];
    //CHAR cText[MAX_PATH];

    //swprintf(szText, L"Frame time = %.03f ms\n"
    //    L"FPS = %.01f\n",
    //    (fFrameTime),
    //    (1000 / fFrameTime));
    //pFont->DrawText(NULL, szText, (int)wcslen(szText), &rc, DT_NOCLIP, dwColor);


    ////btQuaternion rot = cam1->GetRot();
    //SetRect(&rc, 10, 50, 100, 100);
    //swprintf(szText, L"Camera pos: x = %.03f y = %.03f z = %.03f\n",
    //    cp.x(), cp.y(), cp.z());
    //pFont->DrawText(NULL, szText, (int)wcslen(szText), &rc, DT_NOCLIP, dwColor);

    ////SetRect(&rc ,10,100,100,100);
    ////swprintf(szText, L"%d x %d\nA = %.03f\n",d3d9->GetWidth(),d3d9->GetHeight(), cam1->GetAspect()); 
    ////pFont->DrawText(NULL, szText, (int)wcslen(szText), &rc, DT_NOCLIP, dwColor);

    //if (pErrBuffer)
    //{
    //    SetRect(&rc, 10, 200, d3d9->GetWidth() - 10, 100);
    //    sprintf(cText, "%s\n", (char*)pErrBuffer->GetBufferPointer());
    //    pFont->DrawTextA(NULL, cText, MAX_PATH, &rc, DT_NOCLIP, dwAlertColor);
    //}

}

void ArkiGame::ProcessEditorInput(double dt)
{
    POINT p;
    // (Use a flag to ensure single-click, or GetAsyncKeyState logic)
    static bool wasPressed = false;

    // CRITICAL FIX: Check if ImGui wants to capture the mouse
    ImGuiIO& io = ImGui::GetIO();
    if (io.WantCaptureMouse)
    {
        // ImGui is handling mouse input (dialog, sliders, buttons, etc.)
        // Don't process selection or gizmo input
        wasPressed = (GetAsyncKeyState(VK_LBUTTON) & 0x8000) != 0;
        return;
    }

    if (GetAsyncKeyState(VK_MENU) & 0x8000)
    {
        if (GetAsyncKeyState(VK_LBUTTON) & 0x8000)
        {
        
            m_pCamEditor->Orbit(-mouseDeltaX * 0.002f, -mouseDeltaY * 0.002f);
        }
        if (GetAsyncKeyState(VK_MBUTTON) & 0x8000)
        {
            m_pCamEditor->Pan(mouseDeltaX * 1.002f, mouseDeltaY * 1.002f);
        }
        if (GetAsyncKeyState(VK_RBUTTON) & 0x8000)
        {
            //m_pCamEditor->Zoom(mouseDeltaX * 1.002f, mouseDeltaY * 1.002f);
			scrollAmount += mouseDeltaY * 0.1002f;
        }


    }
    else
    {
        // Additional input processing (e.g., GUI) can go here
        // Check Left Mouse Button Click
        bool isPressed = (GetAsyncKeyState(VK_LBUTTON) & 0x8000) != 0;
        // Get Mouse Position (Windows API)
        GetCursorPos(&p);
        ScreenToClient(d3d9->GetHWND(), &p); // Convert to window local coordinates
        btVector3 hitPoint;
        btRigidBody* hitBody = nullptr;
        bool raycastHit = RaycastFromMouse(p.x, p.y, hitPoint, hitBody);

            // 3. Convert to Bullet Vectors
            btVector3 rayFrom(vNear.x, vNear.y, vNear.z);
            btVector3 rayTo(vFar.x, vFar.y, vFar.z);

            //if (isPressed && !wasPressed)
            //{
            if (g_gizmo)
            {
                // STATE MACHINE LOGIC
                if (g_gizmo->IsActive())
                {
                    // State A: User is holding the mouse down and moving an axis
                    g_gizmo->UpdateDrag(vNear, rayDir);
                    _print(L"Draggggggg\n");
                }
                else
                {
                    // State B: User is just moving mouse around
                    // Check if we are hovering over an arrow (to highlight it yellow)
                    g_gizmo->UpdateHover(vNear, rayDir);
                }
            }

            if (isPressed && !wasPressed) 
            {
                if (raycastHit) 
                {
                    if (g_selected) g_selected->m_isSelected = false; // Deselect old
                    //_print(L"Clicked at: X=%.2f Y=%.2f Z=%.2f\n", hitPoint.x(), hitPoint.y(), hitPoint.z());
                    _print(L"Hit Body: %p\n", hitBody);
                    // Search logic (In real engine, store CGameObject* in UserPointer of btRigidBody)
                    for (auto obj : m_sceneObjects)
                    {
                        if (obj->m_rigidBody == hitBody)
                        {
                            g_selected = obj;
                            g_selected->m_isSelected = true;
                            g_gizmo->SetTarget(g_selected);
                            g_gizmo->OnMouseDown(vNear, rayDir);

                            break;
                        }
                    }

                }
                else
                {
                    // Clicked void, deselect
                    if (g_selected) g_selected->m_isSelected = false;
                    g_selected = NULL;
                    g_gizmo->SetTarget(NULL);
                }
                // 2. Check Gizmo First
                //if (g_gizmo && g_selected)
                //{
                //    g_gizmo->OnMouseDown(D3DXVECTOR3(rayFrom.x(), rayFrom.y(), rayFrom.z()), D3DXVECTOR3(rayTo.x(), rayTo.y(), rayTo.z()));
                //    if (g_gizmo->IsActive()) return; // We are dragging the gizmo, don't select new object
                //}
            }
			if (wasPressed && !isPressed)
            {
                // Mouse Released
                if (g_gizmo && g_gizmo->IsActive())
                {
                    g_gizmo->OnMouseUp();
                }
            }
            //    if (hitBody && hitBody->getUserPointer())
            //    {
            //        PhysicsData* data = (PhysicsData*)hitBody->getUserPointer();

            //        // --- INTERACTION LOGIC ---
            //        if (data->type == TYPE_BLOCK)
            //        {
            //            _print(L"Clicked on a BLOCK!\n");
            //            // Example: Destroy block on click (Editor Mode?)
            //            CArkiBlock* block = (CArkiBlock*)data->pObject;
            //           // block->m_pendingDestruction = true;
            //        }
            //        else if (data->type == TYPE_PLAYER)
            //        {
            //            _print(L"Clicked on PLAYER!\n");
            //        }
                
            
            
        
        wasPressed = isPressed;

    }
    // Zoom in/out
    m_pCamEditor->Zoom(scrollAmount * 2.0f); // Multiplier for speed

}

void ArkiGame::ProcessGameInput(double dt)
{
    float moveSpeed = 15.0f * (float)dt;

    if (GetAsyncKeyState(VK_CONTROL) & 0x8000) {
        m_pCam0->RotateFPS(-mouseDeltaY * 0.002f, -mouseDeltaX * 0.002f);

    }

    //cam0->RotateLocal(-mouseDeltaY * 0.002f, -mouseDeltaX * 0.002f, 0);
    // Keyboard Movement
    if (GetAsyncKeyState('W') & 0x8000) m_pCam0->MoveLocal(moveSpeed, 0, 0);
    if (GetAsyncKeyState('S') & 0x8000) m_pCam0->MoveLocal(-moveSpeed, 0, 0);
    if (GetAsyncKeyState('A') & 0x8000) m_pCam0->MoveLocal(0, -moveSpeed, 0);
    if (GetAsyncKeyState('D') & 0x8000) m_pCam0->MoveLocal(0, moveSpeed, 0);
    if ( GetAsyncKeyState(VK_LEFT) & 0x8000) m_inputLeft = true;
	else m_inputLeft = false;
    if (GetAsyncKeyState(VK_RIGHT) & 0x8000) m_inputRight = true;
    else m_inputRight = false;

    if (!isBallActive && GetAsyncKeyState(VK_SPACE))
    {
        m_ball->Launch();
        isBallActive = true;
    }
    else if(isBallActive && GetAsyncKeyState(VK_SPACE))
    {
		m_player->Shoot();


    }
    // Fly Up/Down
    //if (GetAsyncKeyState(VK_SPACE) & 0x8000)   m_pCam0->MoveLocal(0, 0, moveSpeed);
    //if (GetAsyncKeyState(VK_CONTROL) & 0x8000) m_pCam0->MoveLocal(0, 0, -moveSpeed);

}

// ------------------------------------------------------------------------------------
// ------------------------------------------------------------------------------------
void ArkiGame::CheckCollisions(btDiscreteDynamicsWorld* dynamicsWorld)
{
    int numManifolds = dynamicsWorld->getDispatcher()->getNumManifolds();

    for (int i = 0; i < numManifolds; i++)
    {
        btPersistentManifold* contactManifold = dynamicsWorld->getDispatcher()->getManifoldByIndexInternal(i);

        // 1. Get the two bodies involved
        const btCollisionObject* obA = contactManifold->getBody0();
        const btCollisionObject* obB = contactManifold->getBody1();

        // 2. Check if they are actually touching
        // (Bullet keeps manifolds for objects strictly close to each other too)
        int numContacts = contactManifold->getNumContacts();
        if (numContacts == 0) continue;

        // 3. Retrieve our custom data
        PhysicsData* dataA = (PhysicsData*)obA->getUserPointer();
        PhysicsData* dataB = (PhysicsData*)obB->getUserPointer();

        if (!dataA || !dataB) continue; // Safety check

        // 4. Logic: Did Ball hit Block?
        // We don't know if A is Ball or B is Ball, so we check both combinations
        PhysicsData* ballData = nullptr;
        PhysicsData* blockData = nullptr;
        PhysicsData* playerData = nullptr;
        PhysicsData* bulletData = nullptr;
        PhysicsData* powerupData = nullptr;


        if (dataA->type == TYPE_BALL) ballData = dataA;
        if (dataB->type == TYPE_BALL) ballData = dataB;

        if (dataA->type == TYPE_BLOCK) blockData = dataA;
        if (dataB->type == TYPE_BLOCK) blockData = dataB;

        if (dataA->type == TYPE_PLAYER) playerData = dataA;
        if (dataB->type == TYPE_PLAYER) playerData = dataB;
         
        if (dataA->type == TYPE_BULLET) bulletData = dataA;
        if (dataB->type == TYPE_BULLET) bulletData = dataB;

        if (dataA->type == TYPE_POWERUP) powerupData = dataA;
        if (dataB->type == TYPE_POWERUP) powerupData = dataB;


        // --- SCENARIO 1: Ball hit Block ---
        if (ballData && blockData)
        {
            CArkiBlock* pBlock = (CArkiBlock*)blockData->pObject;

            if (!pBlock->m_isDestroyed && !pBlock->m_pendingDestruction)
            {
                pBlock->m_pendingDestruction = true;


                PlayAudioFromMemory(GenerateMutedKnock());
                // Play Sound here...
                // Add Score here...
                if (PullFromDeck())
                {
                    // Get Block Position
                    btTransform trans = pBlock->m_pBody->getWorldTransform();

                    // Random Type
                    //PowerupType type = (PowerupType)(rand() % 5); // Assuming you have 3 types defined
                    PowerupType type = PickWeightedType();

                    CArkiPowerup* newPowerup = new CArkiPowerup(g_dynamicsWorld, trans.getOrigin(), type);
                    m_powerups.push_back(newPowerup);
                }

            }
        }
        if (bulletData && blockData)
        {
            CArkiBlock* pBlock = (CArkiBlock*)blockData->pObject;
            CArkiBullet* pBullet = (CArkiBullet*)bulletData->pObject;


            if (!pBlock->m_isDestroyed && !pBlock->m_pendingDestruction)
            {
                pBlock->m_pendingDestruction = true;
                // Play Sound here...
                // Add Score here...
               
            }
            if (!pBullet->m_markForDelete)
            {
                pBullet->m_markForDelete = true; // Destroy Bullet
            }

            // 20% Chance to spawn powerup
            //if (rand() % 100 < 20)
            if (PullFromDeck())
            {
                // Get Block Position
                btTransform trans = ((CArkiBlock*)dataB->pObject)->m_pBody->getWorldTransform();

                // Random Type
                //PowerupType type = (PowerupType)(rand() % 5); // Assuming you have 3 types defined
                PowerupType type = PickWeightedType();

                CArkiPowerup* newPowerup = new CArkiPowerup(g_dynamicsWorld, trans.getOrigin(), type);
                m_powerups.push_back(newPowerup);
            }
          
        }
		if (powerupData && playerData)
        {
            CArkiPowerup* pPowerup = (CArkiPowerup*)powerupData->pObject;
            CArkiPlayer* pPlayer = (CArkiPlayer*)playerData->pObject;
            if (!pPowerup->m_collected)
            {
                pPowerup->m_collected = true;
                pPowerup->m_markForDelete = true;

				PlayAudioFromMemory(GeneratePowerupSound());
                // Apply effect based on type
                switch (pPowerup->m_type)
                {
                    case PU_HEALTH:
                        //pPlayer->m_lives += 1;
                        break;
                    //case POWERUP_SPEED_BOOST:
                    //    pPlayer->ActivateSpeedBoost(10.0f); // 10 seconds
                    //    break;
                    //case POWERUP_SHIELD:
                    //    pPlayer->ActivateShield(10.0f); // 10 seconds
                    //    break;
                    //case POWERUP_DOUBLE_POINTS:
                    //    pPlayer->ActivateDoublePoints(15.0f); // 15 seconds
                    //    break;
                    //case POWERUP_MULTI_BALL:
                    //    m_ball->SpawnAdditionalBalls(2); // Spawn 2 extra balls
                    //    break;
                }
            }
        }

        // --- SCENARIO 2: Ball hit Player (The "English" Effect) ---
        if (ballData && playerData)
        {
            // Optional: Adjust bounce angle based on where it hit the paddle
            // This gives the player control over the ball

            CArkiBall* pBall = (CArkiBall*)ballData->pObject;
            CArkiPlayer* pPlayer = (CArkiPlayer*)playerData->pObject;

            btTransform ballTrans = pBall->m_pBody->getWorldTransform();
            btTransform playerTrans = pPlayer->m_pBody->getWorldTransform();

            float ballX = static_cast<float>(ballTrans.getOrigin().getX());
            float playerX = static_cast<float>(playerTrans.getOrigin().getX());

            float diff = ballX - playerX; // -1 (left side) to +1 (right side)

            // Add horizontal velocity based on hit position
            btVector3 velocity = pBall->m_pBody->getLinearVelocity();
            velocity.setX(velocity.getX() + (diff * 5.0f)); // 5.0f is the "spin" strength
            pBall->m_pBody->setLinearVelocity(velocity);
        }
    }
}

// Helper to Cast a Ray from Camera into World
// Returns true if we hit something, and fills 'hitPoint' and 'pBody'
bool ArkiGame::RaycastFromMouse(int mouseX, int mouseY, btVector3& outHitPoint, btRigidBody*& outBody)
{
    if (!m_pCam0 || !g_dynamicsWorld) return false;

    // 1. Get Viewport, Projection, and View Matrices
    D3DVIEWPORT9 vp;
    d3d9->GetDevice()->GetViewport(&vp);

    D3DXMATRIX matProj, matView, matWorld;
    d3d9->GetDevice()->GetTransform(D3DTS_PROJECTION, &matProj);
    d3d9->GetDevice()->GetTransform(D3DTS_VIEW, &matView);
    D3DXMatrixIdentity(&matWorld); // We pick in World Space, so World Matrix is Identity

    // 2. Unproject Near and Far points
    // This creates a line segment starting at the camera lens (Near) 
    // and ending at the far clip plane (Far) passing through the mouse cursor.
    D3DXVECTOR3 vMouse((float)mouseX, (float)mouseY, 0.0f);

    // z=0 for near plane, z=1 for far plane
    vMouse.z = 0.0f;
    D3DXVec3Unproject(&vNear, &vMouse, &vp, &matProj, &matView, &matWorld);

    vMouse.z = 1.0f;
    D3DXVec3Unproject(&vFar, &vMouse, &vp, &matProj, &matView, &matWorld);

    // 3. Convert to Bullet Vectors
    btVector3 rayFrom(vNear.x, vNear.y, vNear.z);
    btVector3 rayTo(vFar.x, vFar.y, vFar.z);
    // Direction = Destination - Source
    rayDir = vFar - vNear;
    D3DXVec3Normalize(&rayDir, &rayDir);
    // 4. Perform Ray Test in Bullet Physics
    btCollisionWorld::ClosestRayResultCallback rayCallback(rayFrom, rayTo);
    g_dynamicsWorld->rayTest(rayFrom, rayTo, rayCallback);

    if (rayCallback.hasHit())
    {
        outHitPoint = rayCallback.m_hitPointWorld;
        outBody = (btRigidBody*)btRigidBody::upcast(rayCallback.m_collisionObject);
        return true;
    }

    return false;
}

void ArkiGame::AddCube(btDiscreteDynamicsWorld* dynamicsWorld, IDirect3DDevice9* device)
{
    // 1. Create Graphics Mesh
    //ID3DXMesh* mesh;
    //D3DXCreateBox(device, 2, 2, 2, &mesh, NULL);

    //// 2. Create Physics Body
    //btCollisionShape* shape = new btBoxShape(btVector3(1, 1, 1));
    //btDefaultMotionState* motionState = new btDefaultMotionState(btTransform(btQuaternion(0, 0, 0, 1), btVector3(0, 5, 0)));
    //btScalar mass = 1.0f;
    //btVector3 inertia(0, 0, 0);
    //shape->calculateLocalInertia(mass, inertia);
    //btRigidBody* body = new btRigidBody(mass, motionState, shape, inertia);

    //dynamicsWorld->addRigidBody(body);

    // 3. Create Wrapper
    //CRigidBody* obj = new CRigidBody(body, mesh);
   // m_sceneObjects.push_back(obj);
}

void ArkiGame::RenderObjectProperties()
{
    if (!g_selected) return;

    ImGui::SetNextWindowSize(ImVec2(300, 400), ImGuiCond_FirstUseEver);
    if (ImGui::Begin("Object Properties", NULL, ImGuiWindowFlags_AlwaysAutoResize))
    {
        ImGui::Text("Selected Object");
        ImGui::Separator();

        // Object Name Section
        ImGui::TextColored(ImVec4(1.0f, 0.5f, 0.0f, 1.0f), "Object Name");
        static char nameBuffer[128] = { 0 };

        // Copy name to buffer on first display
        if (nameBuffer[0] == 0)
        {
            strcpy_s(nameBuffer, sizeof(nameBuffer), g_selected->m_name.c_str());
        }

        if (ImGui::InputText("##name", nameBuffer, sizeof(nameBuffer)))
        {
            g_selected->SetName(std::string(nameBuffer));
        }

        ImGui::Separator();
        // Position Section
        ImGui::TextColored(ImVec4(1.0f, 1.0f, 0.0f, 1.0f), "Position");
        static float position[3] = { 0.0f, 0.0f, 0.0f };
        position[0] = g_selected->m_position.x;
        position[1] = g_selected->m_position.y;
        position[2] = g_selected->m_position.z;

        if (ImGui::DragFloat("X##pos", &position[0], 0.1f))
            g_selected->SetPosition(position[0], position[1], position[2]);
        if (ImGui::DragFloat("Y##pos", &position[1], 0.1f))
            g_selected->SetPosition(position[0], position[1], position[2]);
        if (ImGui::DragFloat("Z##pos", &position[2], 0.1f))
            g_selected->SetPosition(position[0], position[1], position[2]);

        ImGui::Spacing();

        // Rotation Section (Euler Angles in Degrees for readability)
        ImGui::TextColored(ImVec4(0.0f, 1.0f, 1.0f, 1.0f), "Rotation");
        float eulerDegrees[3];
        eulerDegrees[0] = D3DXToDegree(g_selected->m_eulerAngles.x);
        eulerDegrees[1] = D3DXToDegree(g_selected->m_eulerAngles.y);
        eulerDegrees[2] = D3DXToDegree(g_selected->m_eulerAngles.z);

        if (ImGui::DragFloat("Yaw##rot", &eulerDegrees[0], 1.0f))
            g_selected->SetRotation(D3DXToRadian(eulerDegrees[0]), D3DXToRadian(eulerDegrees[1]), D3DXToRadian(eulerDegrees[2]));
        if (ImGui::DragFloat("Pitch##rot", &eulerDegrees[1], 1.0f))
            g_selected->SetRotation(D3DXToRadian(eulerDegrees[0]), D3DXToRadian(eulerDegrees[1]), D3DXToRadian(eulerDegrees[2]));
        if (ImGui::DragFloat("Roll##rot", &eulerDegrees[2], 1.0f))
            g_selected->SetRotation(D3DXToRadian(eulerDegrees[0]), D3DXToRadian(eulerDegrees[1]), D3DXToRadian(eulerDegrees[2]));

        ImGui::Spacing();

        // Scale Section
        ImGui::TextColored(ImVec4(1.0f, 0.0f, 1.0f, 1.0f), "Scale");
        static float scale[3] = { 1.0f, 1.0f, 1.0f };
        scale[0] = g_selected->m_scale.x;
        scale[1] = g_selected->m_scale.y;
        scale[2] = g_selected->m_scale.z;

        if (ImGui::DragFloat("Scale X", &scale[0], 0.1f, 0.1f, 100.0f))
            g_selected->m_scale = D3DXVECTOR3(scale[0], scale[1], scale[2]);
        if (ImGui::DragFloat("Scale Y", &scale[1], 0.1f, 0.1f, 100.0f))
            g_selected->m_scale = D3DXVECTOR3(scale[0], scale[1], scale[2]);
        if (ImGui::DragFloat("Scale Z", &scale[2], 0.1f, 0.1f, 100.0f))
            g_selected->m_scale = D3DXVECTOR3(scale[0], scale[1], scale[2]);

        ImGui::Spacing();
        ImGui::Separator();

        // Reset Button
        if (ImGui::Button("Reset Transform"))
        {
            g_selected->SetPosition(0.0f, 0.0f, 0.0f);
            g_selected->SetRotation(0.0f, 0.0f, 0.0f);
            g_selected->m_scale = D3DXVECTOR3(1.0f, 1.0f, 1.0f);
        }
        ImGui::SameLine();
        if (ImGui::Checkbox("Snapping", &m_usesnap))
        {
            g_gizmo->SetSnapping(m_usesnap, 0.1f);
        }
        g_selected->RescaleObject(btVector3(g_selected->m_scale.x, g_selected->m_scale.y, g_selected->m_scale.z));

        ImGui::End();
    }
}

// ---------------------------------------------------------
// 1. INITIALIZATION (Call this in ArkiGame::Init)
// ---------------------------------------------------------
void ArkiGame::InitBagSystem()
{
    // Seed the RNG with hardware entropy (makes it truly random every run)
    std::random_device rd;
    m_rng.seed(rd());

    // Prepare the first bag
    m_deckIndex = 0;
    m_dropDeck.clear();

    // -- CONFIGURATION: 20% Chance --
    // We put 10 items in the bag:
    // 2 are TRUE (Powerup)
    // 8 are FALSE (Nothing)

    m_dropDeck.push_back(true);
    m_dropDeck.push_back(true);

    for (int i = 0; i < 8; i++) {
        m_dropDeck.push_back(false);
    }

    // Shuffle the bag immediately
    std::shuffle(m_dropDeck.begin(), m_dropDeck.end(), m_rng);
}

// ---------------------------------------------------------
// 2. THE BAG LOGIC (Draws a card, reshuffles if empty)
// ---------------------------------------------------------
bool ArkiGame::PullFromDeck()
{
    // 1. Read the result at current index
    bool result = m_dropDeck[m_deckIndex];

    // 2. Move to next card
    m_deckIndex++;

    // 3. If we used all cards, reshuffle the deck!
    if (m_deckIndex >= m_dropDeck.size())
    {
        // Shuffle existing values (2 Trues, 8 Falses) to new positions
        std::shuffle(m_dropDeck.begin(), m_dropDeck.end(), m_rng);
        m_deckIndex = 0;
    }

    return result;
}

// ---------------------------------------------------------
// 3. WEIGHTED TYPE PICKER (Better than rand() % 5)
// ---------------------------------------------------------
PowerupType ArkiGame::PickWeightedType()
{
    // We roll a number 0-100 to decide rarity
    std::uniform_int_distribution<int> dist(0, 100);
    int roll = dist(m_rng);

    // LOGIC:
    // 50% chance for Paddle Increase
    // 30% chance for Laser
    // 15% chance for Sticky
    // 5%  chance for Extra Life

    if (roll < 50) return PU_HEALTH; // Most Common
    roll -= 50;

    if (roll < 30) return PU_ARMOR;
    roll -= 30;

    if (roll < 15) return PU_BALL;

    return PU_GUN; // Rarest
}